<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<link rel="canonical" href="https://meshlib.io/documentation/Cpp/group__FillHoleGroup.html" />
<meta name="robots" content="noindex"/>
<script type="text/javascript">
  !function () {
    var currentHost = window.location.hostname;
    var currentPath = window.location.pathname;
    if (currentHost === 'meshinspector.github.io' && !currentPath.includes('/MeshLib/dev/')) {
      var newPath = currentPath.replace('/MeshLib/html', '/documentation');
      var newURL = 'https://meshlib.io' + newPath + window.location.search + window.location.hash;
      window.location.replace(newURL);
    }
  }();
</script>
<script>
  !function(){var i="analytics",analytics=window[i]=window[i]||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","screen","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware","register"];analytics.factory=function(e){return function(){if(window[i].initialized)return window[i][e].apply(window[i],arguments);var n=Array.prototype.slice.call(arguments);if(["track","screen","alias","group","page","identify"].indexOf(e)>-1){var c=document.querySelector("link[rel='canonical']");n.push({__t:"bpc",c:c&&c.getAttribute("href")||void 0,p:location.pathname,u:location.href,s:location.search,t:document.title,r:document.referrer})}n.unshift(e);analytics.push(n);return analytics}};for(var n=0;n<analytics.methods.length;n++){var key=analytics.methods[n];analytics[key]=analytics.factory(key)}analytics.load=function(key,n){var t=document.createElement("script");t.type="text/javascript";t.async=!0;t.setAttribute("data-global-segment-analytics-key",i);t.src="https://cdn.segment.com/analytics.js/v1/" + key + "/analytics.min.js";var r=document.getElementsByTagName("script")[0];r.parentNode.insertBefore(t,r);analytics._loadOptions=n};analytics._writeKey="Fi7y6F1GgFvTTomYo8zvETBoGHkDDxGx";;analytics.SNIPPET_VERSION="5.2.0";
  analytics.load("Fi7y6F1GgFvTTomYo8zvETBoGHkDDxGx");
  analytics.page();
  }}();
</script>
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-MBPLX27B');</script>
  <!-- End Google Tag Manager -->
<meta name="robots" content="noindex, nofollow">
 <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshLib C++ Docs: Fill/Stitch Holes overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CustomStyle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
    DoxygenAwesomeTabs.init()
</script>
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MBPLX27B"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><a href="https://meshlib.io/"><img alt="Logo" src="favicon.ico"/></a></td>
  <td id="projectalign">
   <div id="projectname">MeshLib C++ Docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__FillHoleGroup.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Fill/Stitch Holes overview<div class="ingroups"><a class="el" href="group__MeshAlgorithmGroup.html">Mesh Algorithm</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>This chapter represents documentation about hole triangulations or stitching two holes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1FillHoleParams.html">MR::FillHoleParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters structure for <a class="el" href="#gac972786878ec37756f5a95814b657a05" title="Fills hole in mesh .">MR::fillHole</a><br  />
Structure has some options to control <a class="el" href="#gac972786878ec37756f5a95814b657a05" title="Fills hole in mesh .">MR::fillHole</a>.  <a href="structMR_1_1FillHoleParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1StitchHolesParams.html">MR::StitchHolesParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters structure for <a class="el" href="#gaa096c69aa6c5cf97a783e92aa3a70157" title="Stitches two holes in Mesh .">MR::buildCylinderBetweenTwoHoles</a><br  />
Structure has some options to control <a class="el" href="#gaa096c69aa6c5cf97a783e92aa3a70157" title="Stitches two holes in Mesh .">MR::buildCylinderBetweenTwoHoles</a>.  <a href="structMR_1_1StitchHolesParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1FillHoleItem.html">MR::FillHoleItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1HoleFillPlan.html">MR::HoleFillPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">concise representation of proposed hole triangulation  <a href="structMR_1_1HoleFillPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MakeBridgeResult.html">MR::MakeBridgeResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1FillHoleMetric.html">MR::FillHoleMetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds metrics for fillHole and buildCylinderBetweenTwoHoles triangulation<br  />
.  <a href="structMR_1_1FillHoleMetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9a2b22c68476e1176c0f8a8f43542611" id="r_ga9a2b22c68476e1176c0f8a8f43542611"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a2b22c68476e1176c0f8a8f43542611">MR::FillTriangleMetric</a> = std::function&lt;double( VertId a, VertId b, VertId c )&gt;</td></tr>
<tr class="separator:ga9a2b22c68476e1176c0f8a8f43542611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f292aee02fc8ca7504a114461b74cd5" id="r_ga7f292aee02fc8ca7504a114461b74cd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f292aee02fc8ca7504a114461b74cd5">MR::FillEdgeMetric</a> = std::function&lt;double( VertId a, VertId b, VertId l, VertId r )&gt;</td></tr>
<tr class="separator:ga7f292aee02fc8ca7504a114461b74cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a9f8a0620df3a7af664ad4c6aab213" id="r_gaf0a9f8a0620df3a7af664ad4c6aab213"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf0a9f8a0620df3a7af664ad4c6aab213">MR::FillCombineMetric</a> = std::function&lt;double( double, double )&gt;</td></tr>
<tr class="separator:gaf0a9f8a0620df3a7af664ad4c6aab213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa096c69aa6c5cf97a783e92aa3a70157" id="r_gaa096c69aa6c5cf97a783e92aa3a70157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa096c69aa6c5cf97a783e92aa3a70157">MR::buildCylinderBetweenTwoHoles</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId a, EdgeId b, const <a class="el" href="structMR_1_1StitchHolesParams.html">StitchHolesParams</a> &amp;params={})</td></tr>
<tr class="memdesc:gaa096c69aa6c5cf97a783e92aa3a70157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stitches two holes in <a class="el" href="structMR_1_1Mesh.html">Mesh</a><br  />
.  <br /></td></tr>
<tr class="separator:gaa096c69aa6c5cf97a783e92aa3a70157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf61677f65331b42d3022a70d4b550a13" id="r_gaf61677f65331b42d3022a70d4b550a13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf61677f65331b42d3022a70d4b550a13">MR::buildCylinderBetweenTwoHoles</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const <a class="el" href="structMR_1_1StitchHolesParams.html">StitchHolesParams</a> &amp;params={})</td></tr>
<tr class="memdesc:gaf61677f65331b42d3022a70d4b550a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">this version finds holes in the mesh by itself and returns false if they are not found  <br /></td></tr>
<tr class="separator:gaf61677f65331b42d3022a70d4b550a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac972786878ec37756f5a95814b657a05" id="r_gac972786878ec37756f5a95814b657a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac972786878ec37756f5a95814b657a05">MR::fillHole</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId a, const <a class="el" href="structMR_1_1FillHoleParams.html">FillHoleParams</a> &amp;params={})</td></tr>
<tr class="memdesc:gac972786878ec37756f5a95814b657a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills hole in mesh<br  />
.  <br /></td></tr>
<tr class="separator:gac972786878ec37756f5a95814b657a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga826414470e5289e2dfba2496f06d98ae" id="r_ga826414470e5289e2dfba2496f06d98ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga826414470e5289e2dfba2496f06d98ae">MR::fillHoles</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const std::vector&lt; EdgeId &gt; &amp;as, const <a class="el" href="structMR_1_1FillHoleParams.html">FillHoleParams</a> &amp;params={})</td></tr>
<tr class="memdesc:ga826414470e5289e2dfba2496f06d98ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill all holes given by their representative edges in  <br /></td></tr>
<tr class="separator:ga826414470e5289e2dfba2496f06d98ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7b07510d4a7d74b02ef6890db04a9d" id="r_ga7b7b07510d4a7d74b02ef6890db04a9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7b7b07510d4a7d74b02ef6890db04a9d">MR::isHoleBd</a> (const <a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;topology, const <a class="el" href="namespaceMR.html#a099da1b4cb4b8348ee3fed0588b01aa3">EdgeLoop</a> &amp;loop)</td></tr>
<tr class="separator:ga7b7b07510d4a7d74b02ef6890db04a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3256109cd439a9801f179661c65c7e6" id="r_gaa3256109cd439a9801f179661c65c7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1HoleFillPlan.html">HoleFillPlan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa3256109cd439a9801f179661c65c7e6">MR::getHoleFillPlan</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId e, const <a class="el" href="structMR_1_1FillHoleParams.html">FillHoleParams</a> &amp;params={})</td></tr>
<tr class="separator:gaa3256109cd439a9801f179661c65c7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dbbac5f3d5dfdebbb1790578aed11d8" id="r_ga1dbbac5f3d5dfdebbb1790578aed11d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1HoleFillPlan.html">HoleFillPlan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1dbbac5f3d5dfdebbb1790578aed11d8">MR::getPlanarHoleFillPlan</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId e)</td></tr>
<tr class="separator:ga1dbbac5f3d5dfdebbb1790578aed11d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac65388f63712128d8af8e1b81054f779" id="r_gac65388f63712128d8af8e1b81054f779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac65388f63712128d8af8e1b81054f779">MR::executeHoleFillPlan</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId a0, <a class="el" href="structMR_1_1HoleFillPlan.html">HoleFillPlan</a> &amp;plan, FaceBitSet *outNewFaces=nullptr)</td></tr>
<tr class="memdesc:gac65388f63712128d8af8e1b81054f779"><td class="mdescLeft">&#160;</td><td class="mdescRight">quickly triangulates the face or hole to the left of (e) given the plan (quickly compared to fillHole function)  <br /></td></tr>
<tr class="separator:gac65388f63712128d8af8e1b81054f779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0241a36cc2b1016fd0cf66e9ae71f722" id="r_ga0241a36cc2b1016fd0cf66e9ae71f722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0241a36cc2b1016fd0cf66e9ae71f722">MR::fillHoleTrivially</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId a, FaceBitSet *outNewFaces=nullptr)</td></tr>
<tr class="memdesc:ga0241a36cc2b1016fd0cf66e9ae71f722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates face of hole in mesh trivially<br  />
.  <br /></td></tr>
<tr class="separator:ga0241a36cc2b1016fd0cf66e9ae71f722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c7779fd4cc2d941f67da4462b2d0121" id="r_ga3c7779fd4cc2d941f67da4462b2d0121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c7779fd4cc2d941f67da4462b2d0121">MR::extendHole</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId a, const Plane3f &amp;plane, FaceBitSet *outNewFaces=nullptr)</td></tr>
<tr class="separator:ga3c7779fd4cc2d941f67da4462b2d0121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98bec93b947e8017b7443801e20bc79b" id="r_ga98bec93b947e8017b7443801e20bc79b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; EdgeId &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga98bec93b947e8017b7443801e20bc79b">MR::extendAllHoles</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const Plane3f &amp;plane, FaceBitSet *outNewFaces=nullptr)</td></tr>
<tr class="separator:ga98bec93b947e8017b7443801e20bc79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga067cc1eda81ae410fdf9299ca802738a" id="r_ga067cc1eda81ae410fdf9299ca802738a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga067cc1eda81ae410fdf9299ca802738a">MR::extendHole</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId a, std::function&lt; Vector3f(const Vector3f &amp;)&gt; getVertPos, FaceBitSet *outNewFaces=nullptr)</td></tr>
<tr class="separator:ga067cc1eda81ae410fdf9299ca802738a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bee2d636a1f5f931ac54f6f841c07f7" id="r_ga7bee2d636a1f5f931ac54f6f841c07f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7bee2d636a1f5f931ac54f6f841c07f7">MR::buildBottom</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId a, Vector3f dir, float holeExtension, FaceBitSet *outNewFaces=nullptr)</td></tr>
<tr class="separator:ga7bee2d636a1f5f931ac54f6f841c07f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d97d0e9b001fe0d4915154d1945e77" id="r_ga10d97d0e9b001fe0d4915154d1945e77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10d97d0e9b001fe0d4915154d1945e77">MR::makeDegenerateBandAroundHole</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId a, FaceBitSet *outNewFaces=nullptr)</td></tr>
<tr class="separator:ga10d97d0e9b001fe0d4915154d1945e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d4d7960f97e0c640fa2d62c25514c2e" id="r_ga2d4d7960f97e0c640fa2d62c25514c2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MakeBridgeResult.html">MakeBridgeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2d4d7960f97e0c640fa2d62c25514c2e">MR::makeQuadBridge</a> (<a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;topology, EdgeId a, EdgeId b, FaceBitSet *outNewFaces=nullptr)</td></tr>
<tr class="separator:ga2d4d7960f97e0c640fa2d62c25514c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad16b63618dae72a30c787fcd1d7b8200" id="r_gad16b63618dae72a30c787fcd1d7b8200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MakeBridgeResult.html">MakeBridgeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad16b63618dae72a30c787fcd1d7b8200">MR::makeBridge</a> (<a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;topology, EdgeId a, EdgeId b, FaceBitSet *outNewFaces=nullptr)</td></tr>
<tr class="separator:gad16b63618dae72a30c787fcd1d7b8200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae081fd1e2bfcbf6522b3c28a35ebced2" id="r_gae081fd1e2bfcbf6522b3c28a35ebced2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MakeBridgeResult.html">MakeBridgeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae081fd1e2bfcbf6522b3c28a35ebced2">MR::makeSmoothBridge</a> (<a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId a, EdgeId b, float samplingStep, FaceBitSet *outNewFaces=nullptr)</td></tr>
<tr class="separator:gae081fd1e2bfcbf6522b3c28a35ebced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86668640c827d61e8ee92b7a74dc558d" id="r_ga86668640c827d61e8ee92b7a74dc558d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga86668640c827d61e8ee92b7a74dc558d">MR::makeBridgeEdge</a> (<a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;topology, EdgeId a, EdgeId b)</td></tr>
<tr class="separator:ga86668640c827d61e8ee92b7a74dc558d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76a068dd3fae29c30797157fd646667" id="r_gad76a068dd3fae29c30797157fd646667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad76a068dd3fae29c30797157fd646667">MR::splitQuad</a> (<a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;topology, EdgeId a, FaceBitSet *outNewFaces=nullptr)</td></tr>
<tr class="memdesc:gad76a068dd3fae29c30797157fd646667"><td class="mdescLeft">&#160;</td><td class="mdescRight">given quadrangle face to the left of a, splits it in two triangles with new diagonal edge via dest(a)  <br /></td></tr>
<tr class="separator:gad76a068dd3fae29c30797157fd646667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f6ba6ec6bdfa6f27d1045e79b9346e" id="r_ga42f6ba6ec6bdfa6f27d1045e79b9346e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga42f6ba6ec6bdfa6f27d1045e79b9346e">MR::calcCombinedFillMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const FaceBitSet &amp;filledRegion, const <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> &amp;metric)</td></tr>
<tr class="memdesc:ga42f6ba6ec6bdfa6f27d1045e79b9346e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes combined metric after filling a hole.  <br /></td></tr>
<tr class="separator:ga42f6ba6ec6bdfa6f27d1045e79b9346e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8991ed600a3fc8cec5258a75d5edb5" id="r_ga1f8991ed600a3fc8cec5258a75d5edb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1f8991ed600a3fc8cec5258a75d5edb5">MR::getCircumscribedMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="separator:ga1f8991ed600a3fc8cec5258a75d5edb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa490c6225ad37e5491af1ed61365e774" id="r_gaa490c6225ad37e5491af1ed61365e774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa490c6225ad37e5491af1ed61365e774">MR::getPlaneFillMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId e)</td></tr>
<tr class="separator:gaa490c6225ad37e5491af1ed61365e774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ca3e797d9308a5db4461b06d773c01" id="r_ga57ca3e797d9308a5db4461b06d773c01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga57ca3e797d9308a5db4461b06d773c01">MR::getPlaneNormalizedFillMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId e)</td></tr>
<tr class="separator:ga57ca3e797d9308a5db4461b06d773c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254a08307d5300b9bc3843d7c8acf653" id="r_ga254a08307d5300b9bc3843d7c8acf653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga254a08307d5300b9bc3843d7c8acf653">MR::getComplexStitchMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="separator:ga254a08307d5300b9bc3843d7c8acf653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc1cb5bc1aba5dea400fb1ea6cc8a63" id="r_ga2bc1cb5bc1aba5dea400fb1ea6cc8a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2bc1cb5bc1aba5dea400fb1ea6cc8a63">MR::getEdgeLengthFillMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga2bc1cb5bc1aba5dea400fb1ea6cc8a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple metric minimizing the sum of all edge lengths.  <br /></td></tr>
<tr class="separator:ga2bc1cb5bc1aba5dea400fb1ea6cc8a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21177488c5c69bed8eba38677306be0b" id="r_ga21177488c5c69bed8eba38677306be0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga21177488c5c69bed8eba38677306be0b">MR::getEdgeLengthStitchMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="separator:ga21177488c5c69bed8eba38677306be0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5fc59fe1db6fed34f037ff6dad6bc44" id="r_gaf5fc59fe1db6fed34f037ff6dad6bc44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf5fc59fe1db6fed34f037ff6dad6bc44">MR::getVerticalStitchMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const Vector3f &amp;upDir)</td></tr>
<tr class="separator:gaf5fc59fe1db6fed34f037ff6dad6bc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01960d0a269898638030197df262046" id="r_gaa01960d0a269898638030197df262046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa01960d0a269898638030197df262046">MR::getComplexFillMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId e)</td></tr>
<tr class="separator:gaa01960d0a269898638030197df262046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a4b77571e011a0b74c0a419e76ef332" id="r_ga9a4b77571e011a0b74c0a419e76ef332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a4b77571e011a0b74c0a419e76ef332">MR::getParallelPlaneFillMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, EdgeId e, const Plane3f *plane=nullptr)</td></tr>
<tr class="memdesc:ga9a4b77571e011a0b74c0a419e76ef332"><td class="mdescLeft">&#160;</td><td class="mdescRight">This metric minimizes summary projection of new edges to plane normal, (try do produce edges parallel to plane)  <br /></td></tr>
<tr class="separator:ga9a4b77571e011a0b74c0a419e76ef332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35620a56c8b1a4eb772c84e4dd9907b" id="r_gab35620a56c8b1a4eb772c84e4dd9907b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab35620a56c8b1a4eb772c84e4dd9907b">MR::getMaxDihedralAngleMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="separator:gab35620a56c8b1a4eb772c84e4dd9907b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a9d70b647d9b9f745ab650b21a975e" id="r_ga16a9d70b647d9b9f745ab650b21a975e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga16a9d70b647d9b9f745ab650b21a975e">MR::getUniversalMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="separator:ga16a9d70b647d9b9f745ab650b21a975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338fbef1b80c5730fcdc31a93c980781" id="r_ga338fbef1b80c5730fcdc31a93c980781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga338fbef1b80c5730fcdc31a93c980781">MR::getMinTriAngleMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga338fbef1b80c5730fcdc31a93c980781"><td class="mdescLeft">&#160;</td><td class="mdescRight">This metric maximizes the minimal angle among all faces in the triangulation.  <br /></td></tr>
<tr class="separator:ga338fbef1b80c5730fcdc31a93c980781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac98959b47ab6fdfe548671b1416e6043" id="r_gac98959b47ab6fdfe548671b1416e6043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac98959b47ab6fdfe548671b1416e6043">MR::getMinAreaMetric</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="separator:gac98959b47ab6fdfe548671b1416e6043"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac632bf42924389cba000b725ef53d7bc" id="r_gac632bf42924389cba000b725ef53d7bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac632bf42924389cba000b725ef53d7bc">MR::BadTriangulationMetric</a></td></tr>
<tr class="separator:gac632bf42924389cba000b725ef53d7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This chapter represents documentation about hole triangulations or stitching two holes. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf0a9f8a0620df3a7af664ad4c6aab213" name="gaf0a9f8a0620df3a7af664ad4c6aab213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0a9f8a0620df3a7af664ad4c6aab213">&#9670;&#160;</a></span>FillCombineMetric</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaf0a9f8a0620df3a7af664ad4c6aab213">MR::FillCombineMetric</a> = std::function&lt;double( double, double )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7f292aee02fc8ca7504a114461b74cd5" name="ga7f292aee02fc8ca7504a114461b74cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f292aee02fc8ca7504a114461b74cd5">&#9670;&#160;</a></span>FillEdgeMetric</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga7f292aee02fc8ca7504a114461b74cd5">MR::FillEdgeMetric</a> = std::function&lt;double( VertId a, VertId b, VertId l, VertId r )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9a2b22c68476e1176c0f8a8f43542611" name="ga9a2b22c68476e1176c0f8a8f43542611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a2b22c68476e1176c0f8a8f43542611">&#9670;&#160;</a></span>FillTriangleMetric</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga9a2b22c68476e1176c0f8a8f43542611">MR::FillTriangleMetric</a> = std::function&lt;double( VertId a, VertId b, VertId c )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7bee2d636a1f5f931ac54f6f841c07f7" name="ga7bee2d636a1f5f931ac54f6f841c07f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bee2d636a1f5f931ac54f6f841c07f7">&#9670;&#160;</a></span>buildBottom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId MR::buildBottom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3f</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>holeExtension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>outNewFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>adds cylindrical extension of given hole represented by one of its edges (having no valid left face) by adding new vertices located in lowest point of the hole -dir*holeExtension and 2 * number_of_hole_edge triangles; </p><dl class="section return"><dt>Returns</dt><dd>the edge of new hole opposite to input edge (a) </dd></dl>

</div>
</div>
<a id="gaf61677f65331b42d3022a70d4b550a13" name="gaf61677f65331b42d3022a70d4b550a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf61677f65331b42d3022a70d4b550a13">&#9670;&#160;</a></span>buildCylinderBetweenTwoHoles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::buildCylinderBetweenTwoHoles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1StitchHolesParams.html">StitchHolesParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this version finds holes in the mesh by itself and returns false if they are not found </p>

</div>
</div>
<a id="gaa096c69aa6c5cf97a783e92aa3a70157" name="gaa096c69aa6c5cf97a783e92aa3a70157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa096c69aa6c5cf97a783e92aa3a70157">&#9670;&#160;</a></span>buildCylinderBetweenTwoHoles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::buildCylinderBetweenTwoHoles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1StitchHolesParams.html">StitchHolesParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stitches two holes in <a class="el" href="structMR_1_1Mesh.html">Mesh</a><br  />
. </p>
<p>Build cylindrical patch to fill space between two holes represented by one of their edges each,<br  />
default metric: ComplexStitchMetric</p>
<div class="image">
<img src="before_stitch.png" alt="" width="250cm"/>
<div class="caption">
Before</div></div>
 <div class="image">
<img src="stitch.png" alt="" width="250cm"/>
<div class="caption">
After</div></div>
<p>Next picture show, how newly generated faces can be smoothed <a class="el" href="namespaceMR.html#ae86354c05ad9fa894a5dd8c50099d7a9">MR::positionVertsSmoothly</a> <a class="el" href="group__MeshSubdivideGroup.html#ga8e8a41112544b99ef8f20e3e6b61fab7">MR::subdivideMesh</a> </p><div class="image">
<img src="stitch_smooth.png" alt="" width="250cm"/>
<div class="caption">
Stitch with smooth</div></div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>mesh with hole </td></tr>
    <tr><td class="paramname">a</td><td>EdgeId which represents 1st hole (should not have valid left FaceId) </td></tr>
    <tr><td class="paramname">b</td><td>EdgeId which represents 2nd hole (should not have valid left FaceId) </td></tr>
    <tr><td class="paramname">params</td><td>parameters of holes stitching</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac972786878ec37756f5a95814b657a05">fillHole</a> </dd>
<dd>
<a class="el" href="structMR_1_1StitchHolesParams.html">StitchHolesParams</a> </dd></dl>

</div>
</div>
<a id="ga42f6ba6ec6bdfa6f27d1045e79b9346e" name="ga42f6ba6ec6bdfa6f27d1045e79b9346e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42f6ba6ec6bdfa6f27d1045e79b9346e">&#9670;&#160;</a></span>calcCombinedFillMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> double MR::calcCombinedFillMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet &amp;</td>          <td class="paramname"><span class="paramname"><em>filledRegion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>metric</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes combined metric after filling a hole. </p>

</div>
</div>
<a id="gac65388f63712128d8af8e1b81054f779" name="gac65388f63712128d8af8e1b81054f779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac65388f63712128d8af8e1b81054f779">&#9670;&#160;</a></span>executeHoleFillPlan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::executeHoleFillPlan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMR_1_1HoleFillPlan.html">HoleFillPlan</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>plan</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>outNewFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>quickly triangulates the face or hole to the left of (e) given the plan (quickly compared to fillHole function) </p>

</div>
</div>
<a id="ga98bec93b947e8017b7443801e20bc79b" name="ga98bec93b947e8017b7443801e20bc79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98bec93b947e8017b7443801e20bc79b">&#9670;&#160;</a></span>extendAllHoles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; EdgeId &gt; MR::extendAllHoles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Plane3f &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>outNewFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>adds cylindrical extension of too all holes of the mesh by calling extendHole(...); </p><dl class="section return"><dt>Returns</dt><dd>representative edges of one per every hole after extension </dd></dl>

</div>
</div>
<a id="ga3c7779fd4cc2d941f67da4462b2d0121" name="ga3c7779fd4cc2d941f67da4462b2d0121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c7779fd4cc2d941f67da4462b2d0121">&#9670;&#160;</a></span>extendHole() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId MR::extendHole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Plane3f &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>outNewFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>adds cylindrical extension of given hole represented by one of its edges (having no valid left face) by adding new vertices located in given plane and 2 * number_of_hole_edge triangles; </p><dl class="section return"><dt>Returns</dt><dd>the edge of new hole opposite to input edge (a) </dd></dl>

</div>
</div>
<a id="ga067cc1eda81ae410fdf9299ca802738a" name="ga067cc1eda81ae410fdf9299ca802738a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga067cc1eda81ae410fdf9299ca802738a">&#9670;&#160;</a></span>extendHole() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId MR::extendHole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Vector3f(const Vector3f &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>getVertPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>outNewFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>adds extension of given hole represented by one of its edges (having no valid left face) by adding new vertices located at getVertPos( existing vertex position ); </p><dl class="section return"><dt>Returns</dt><dd>the edge of new hole opposite to input edge (a) </dd></dl>

</div>
</div>
<a id="gac972786878ec37756f5a95814b657a05" name="gac972786878ec37756f5a95814b657a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac972786878ec37756f5a95814b657a05">&#9670;&#160;</a></span>fillHole()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::fillHole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1FillHoleParams.html">FillHoleParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills hole in mesh<br  />
. </p>
<p>Fills given hole represented by one of its edges (having no valid left face),<br  />
uses fillHoleTrivially if cannot fill hole without multiple edges,<br  />
default metric: CircumscribedFillMetric</p>
<div class="image">
<img src="before_fill.png" alt="" width="250cm"/>
<div class="caption">
Before</div></div>
 <div class="image">
<img src="fill.png" alt="" width="250cm"/>
<div class="caption">
After</div></div>
<p>Next picture show, how newly generated faces can be smoothed <a class="el" href="namespaceMR.html#ae86354c05ad9fa894a5dd8c50099d7a9">MR::positionVertsSmoothly</a> <a class="el" href="group__MeshSubdivideGroup.html#ga8e8a41112544b99ef8f20e3e6b61fab7">MR::subdivideMesh</a> </p><div class="image">
<img src="fill_smooth.png" alt="" width="250cm"/>
<div class="caption">
Fill with smooth</div></div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>mesh with hole </td></tr>
    <tr><td class="paramname">a</td><td>EdgeId which represents hole (should not have valid left FaceId) </td></tr>
    <tr><td class="paramname">params</td><td>parameters of hole filling</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa096c69aa6c5cf97a783e92aa3a70157">buildCylinderBetweenTwoHoles</a> </dd>
<dd>
<a class="el" href="#ga0241a36cc2b1016fd0cf66e9ae71f722">fillHoleTrivially</a> </dd>
<dd>
<a class="el" href="structMR_1_1FillHoleParams.html">FillHoleParams</a> </dd></dl>

</div>
</div>
<a id="ga826414470e5289e2dfba2496f06d98ae" name="ga826414470e5289e2dfba2496f06d98ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga826414470e5289e2dfba2496f06d98ae">&#9670;&#160;</a></span>fillHoles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::fillHoles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; EdgeId &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>as</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1FillHoleParams.html">FillHoleParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fill all holes given by their representative edges in </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0241a36cc2b1016fd0cf66e9ae71f722" name="ga0241a36cc2b1016fd0cf66e9ae71f722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0241a36cc2b1016fd0cf66e9ae71f722">&#9670;&#160;</a></span>fillHoleTrivially()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId MR::fillHoleTrivially </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>outNewFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangulates face of hole in mesh trivially<br  />
. </p>
<p>Fills given hole represented by one of its edges (having no valid left face)<br  />
by creating one new vertex in the centroid of boundary vertices and connecting new vertex with all boundary vertices.</p>
<div class="image">
<img src="before_fill.png" alt="" width="250cm"/>
<div class="caption">
Before</div></div>
 <div class="image">
<img src="fill_triv.png" alt="" width="250cm"/>
<div class="caption">
After</div></div>
<p>Next picture show, how newly generated faces can be smoothed <a class="el" href="namespaceMR.html#ae86354c05ad9fa894a5dd8c50099d7a9">MR::positionVertsSmoothly</a> <a class="el" href="group__MeshSubdivideGroup.html#ga8e8a41112544b99ef8f20e3e6b61fab7">MR::subdivideMesh</a> </p><div class="image">
<img src="fill_triv_smooth.png" alt="" width="250cm"/>
<div class="caption">
Trivial fill with smooth</div></div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>mesh with hole </td></tr>
    <tr><td class="paramname">a</td><td>EdgeId points on the face or hole to the left that will be triangulated </td></tr>
    <tr><td class="paramname">outNewFaces</td><td>optional output newly generated faces </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vertex</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac972786878ec37756f5a95814b657a05">fillHole</a> </dd></dl>

</div>
</div>
<a id="ga1f8991ed600a3fc8cec5258a75d5edb5" name="ga1f8991ed600a3fc8cec5258a75d5edb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f8991ed600a3fc8cec5258a75d5edb5">&#9670;&#160;</a></span>getCircumscribedMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getCircumscribedMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This metric minimizes the sum of circumcircle radii for all triangles in the triangulation. It is rather fast to calculate, and it results in typically good triangulations. </p>

</div>
</div>
<a id="gaa01960d0a269898638030197df262046" name="gaa01960d0a269898638030197df262046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa01960d0a269898638030197df262046">&#9670;&#160;</a></span>getComplexFillMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getComplexFillMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This metric minimizes the sum of triangleMetric for all triangles in the triangulation plus the sum edgeMetric for all edges inside and on the boundary of the triangulation.<br  />
Where<br  />
triangleMetric is proportional to weighted triangle area and triangle aspect ratio<br  />
edgeMetric grows with angle between triangles as ( ( 1 - cos( x ) ) / ( 1 + cos( x ) ) ) ^ 4. </p>

</div>
</div>
<a id="ga254a08307d5300b9bc3843d7c8acf653" name="ga254a08307d5300b9bc3843d7c8acf653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga254a08307d5300b9bc3843d7c8acf653">&#9670;&#160;</a></span>getComplexStitchMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getComplexStitchMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This metric minimizes the sum of triangleMetric for all triangles in the triangulation plus the sum edgeMetric for all edges inside and on the boundary of the triangulation.<br  />
Where<br  />
triangleMetric is proportional to triangle aspect ratio<br  />
edgeMetric is proportional to ( 1 - dihedralAngleCos ) </p>

</div>
</div>
<a id="ga2bc1cb5bc1aba5dea400fb1ea6cc8a63" name="ga2bc1cb5bc1aba5dea400fb1ea6cc8a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bc1cb5bc1aba5dea400fb1ea6cc8a63">&#9670;&#160;</a></span>getEdgeLengthFillMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getEdgeLengthFillMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple metric minimizing the sum of all edge lengths. </p>

</div>
</div>
<a id="ga21177488c5c69bed8eba38677306be0b" name="ga21177488c5c69bed8eba38677306be0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21177488c5c69bed8eba38677306be0b">&#9670;&#160;</a></span>getEdgeLengthStitchMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getEdgeLengthStitchMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forbids connecting vertices from the same hole <br  />
Simple metric minimizing edge length </p>

</div>
</div>
<a id="gaa3256109cd439a9801f179661c65c7e6" name="gaa3256109cd439a9801f179661c65c7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3256109cd439a9801f179661c65c7e6">&#9670;&#160;</a></span>getHoleFillPlan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1HoleFillPlan.html">HoleFillPlan</a> MR::getHoleFillPlan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1FillHoleParams.html">FillHoleParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prepares the plan how to triangulate the face or hole to the left of (e) (not filling it immediately), several getHoleFillPlan can work in parallel </p>

</div>
</div>
<a id="gab35620a56c8b1a4eb772c84e4dd9907b" name="gab35620a56c8b1a4eb772c84e4dd9907b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab35620a56c8b1a4eb772c84e4dd9907b">&#9670;&#160;</a></span>getMaxDihedralAngleMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getMaxDihedralAngleMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This metric minimizes the maximal dihedral angle between the faces in the triangulation and on its boundary </p>

</div>
</div>
<a id="gac98959b47ab6fdfe548671b1416e6043" name="gac98959b47ab6fdfe548671b1416e6043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac98959b47ab6fdfe548671b1416e6043">&#9670;&#160;</a></span>getMinAreaMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getMinAreaMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This metric is for triangulation construction with minimal summed area of triangles. Warning: this metric can produce degenerated triangles </p>

</div>
</div>
<a id="ga338fbef1b80c5730fcdc31a93c980781" name="ga338fbef1b80c5730fcdc31a93c980781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga338fbef1b80c5730fcdc31a93c980781">&#9670;&#160;</a></span>getMinTriAngleMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getMinTriAngleMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This metric maximizes the minimal angle among all faces in the triangulation. </p>

</div>
</div>
<a id="ga9a4b77571e011a0b74c0a419e76ef332" name="ga9a4b77571e011a0b74c0a419e76ef332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a4b77571e011a0b74c0a419e76ef332">&#9670;&#160;</a></span>getParallelPlaneFillMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getParallelPlaneFillMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Plane3f *</td>          <td class="paramname"><span class="paramname"><em>plane</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This metric minimizes summary projection of new edges to plane normal, (try do produce edges parallel to plane) </p>

</div>
</div>
<a id="ga1dbbac5f3d5dfdebbb1790578aed11d8" name="ga1dbbac5f3d5dfdebbb1790578aed11d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dbbac5f3d5dfdebbb1790578aed11d8">&#9670;&#160;</a></span>getPlanarHoleFillPlan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1HoleFillPlan.html">HoleFillPlan</a> MR::getPlanarHoleFillPlan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prepares the plan how to triangulate the planar face or planar hole to the left of (e) (not filling it immediately), several getPlanarHoleFillPlan can work in parallel </p>

</div>
</div>
<a id="gaa490c6225ad37e5491af1ed61365e774" name="gaa490c6225ad37e5491af1ed61365e774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa490c6225ad37e5491af1ed61365e774">&#9670;&#160;</a></span>getPlaneFillMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getPlaneFillMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as getCircumscribedFillMetric, but with extra penalty for the triangles having normals looking in the opposite side of plane containing left of (e). </p>

</div>
</div>
<a id="ga57ca3e797d9308a5db4461b06d773c01" name="ga57ca3e797d9308a5db4461b06d773c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57ca3e797d9308a5db4461b06d773c01">&#9670;&#160;</a></span>getPlaneNormalizedFillMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getPlaneNormalizedFillMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to getPlaneFillMetric with extra penalty for the triangles having normals looking in the opposite side of plane containing left of (e), but the metric minimizes the sum of circumcircle radius times aspect ratio for all triangles in the triangulation. </p>

</div>
</div>
<a id="ga16a9d70b647d9b9f745ab650b21a975e" name="ga16a9d70b647d9b9f745ab650b21a975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16a9d70b647d9b9f745ab650b21a975e">&#9670;&#160;</a></span>getUniversalMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getUniversalMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This metric minimizes the maximal dihedral angle between the faces in the triangulation and on its boundary, and it avoids creating too degenerate triangles; for planar holes it is the same as getCircumscribedMetric </p>

</div>
</div>
<a id="gaf5fc59fe1db6fed34f037ff6dad6bc44" name="gaf5fc59fe1db6fed34f037ff6dad6bc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5fc59fe1db6fed34f037ff6dad6bc44">&#9670;&#160;</a></span>getVerticalStitchMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1FillHoleMetric.html">FillHoleMetric</a> MR::getVerticalStitchMetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>upDir</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forbids connecting vertices from the same hole <br  />
All new faces should be parallel to given direction </p>

</div>
</div>
<a id="ga7b7b07510d4a7d74b02ef6890db04a9d" name="ga7b7b07510d4a7d74b02ef6890db04a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b7b07510d4a7d74b02ef6890db04a9d">&#9670;&#160;</a></span>isHoleBd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::isHoleBd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a099da1b4cb4b8348ee3fed0588b01aa3">EdgeLoop</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>loop</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns true if given loop is a boundary of one hole in given mesh topology:</p><ul>
<li>every edge in the loop does not have left face,</li>
<li>next/prev edges in the loop are related as follows: next = topology.prev( prev.sym() ) if the function returns true, then any edge from the loop passed to <a class="el" href="#gac972786878ec37756f5a95814b657a05">fillHole</a> will fill the same hole </li>
</ul>

</div>
</div>
<a id="gad16b63618dae72a30c787fcd1d7b8200" name="gad16b63618dae72a30c787fcd1d7b8200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad16b63618dae72a30c787fcd1d7b8200">&#9670;&#160;</a></span>makeBridge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MakeBridgeResult.html">MakeBridgeResult</a> MR::makeBridge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>outNewFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>creates a bridge between two boundary edges a and b (both having no valid left face); bridge consists of two triangles in general or of one triangle if a and b are neighboring edges on the boundary; </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="structMR_1_1MakeBridgeResult.html">MakeBridgeResult</a> evaluating to false if bridge cannot be created because otherwise multiple edges appear </dd></dl>

</div>
</div>
<a id="ga86668640c827d61e8ee92b7a74dc558d" name="ga86668640c827d61e8ee92b7a74dc558d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86668640c827d61e8ee92b7a74dc558d">&#9670;&#160;</a></span>makeBridgeEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId MR::makeBridgeEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>creates a new bridge edge between origins of two boundary edges a and b (both having no valid left face); </p><dl class="section return"><dt>Returns</dt><dd>invalid id if bridge cannot be created because otherwise multiple edges appear </dd></dl>

</div>
</div>
<a id="ga10d97d0e9b001fe0d4915154d1945e77" name="ga10d97d0e9b001fe0d4915154d1945e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10d97d0e9b001fe0d4915154d1945e77">&#9670;&#160;</a></span>makeDegenerateBandAroundHole()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId MR::makeDegenerateBandAroundHole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>outNewFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>creates a band of degenerate triangles around given hole; </p><dl class="section return"><dt>Returns</dt><dd>the edge of new hole opposite to input edge (a) </dd></dl>

</div>
</div>
<a id="ga2d4d7960f97e0c640fa2d62c25514c2e" name="ga2d4d7960f97e0c640fa2d62c25514c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d4d7960f97e0c640fa2d62c25514c2e">&#9670;&#160;</a></span>makeQuadBridge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MakeBridgeResult.html">MakeBridgeResult</a> MR::makeQuadBridge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>outNewFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>creates a bridge between two boundary edges a and b (both having no valid left face); bridge consists of one quadrangle in general (beware that it cannot be rendered) or of one triangle if a and b are neighboring edges on the boundary; </p><dl class="section return"><dt>Returns</dt><dd>false if bridge cannot be created because otherwise multiple edges appear </dd></dl>

</div>
</div>
<a id="gae081fd1e2bfcbf6522b3c28a35ebced2" name="gae081fd1e2bfcbf6522b3c28a35ebced2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae081fd1e2bfcbf6522b3c28a35ebced2">&#9670;&#160;</a></span>makeSmoothBridge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MakeBridgeResult.html">MakeBridgeResult</a> MR::makeSmoothBridge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>samplingStep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>outNewFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>creates a bridge between two boundary edges a and b (both having no valid left face); bridge consists of strip of quadrangles (each consisting of two triangles) in general or of some triangles if a and b are neighboring edges on the boundary; the bridge is made as smooth as possible with small angles in between its links and on the boundary with existed triangles; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplingStep</td><td>boundaries of the bridge will be subdivided until the distance between neighbor points becomes less than this distance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structMR_1_1MakeBridgeResult.html">MakeBridgeResult</a> evaluating to false if bridge cannot be created because otherwise multiple edges appear </dd></dl>

</div>
</div>
<a id="gad76a068dd3fae29c30797157fd646667" name="gad76a068dd3fae29c30797157fd646667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76a068dd3fae29c30797157fd646667">&#9670;&#160;</a></span>splitQuad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::splitQuad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>outNewFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>given quadrangle face to the left of a, splits it in two triangles with new diagonal edge via dest(a) </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gac632bf42924389cba000b725ef53d7bc" name="gac632bf42924389cba000b725ef53d7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac632bf42924389cba000b725ef53d7bc">&#9670;&#160;</a></span>BadTriangulationMetric</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> const double MR::BadTriangulationMetric</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Big value, but less then DBL_MAX, to be able to pass some bad triangulations instead of breaking it e10 - real metrics to have weight in triangulation, if it would be more than e15+ some metrics will be less than double precision </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.11.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a rel="nofollow" href="https://www.doxygen.nl/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
