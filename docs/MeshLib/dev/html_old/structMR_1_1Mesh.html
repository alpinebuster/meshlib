<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<script type="text/javascript">
  !function () {
    var currentHost = window.location.hostname;
    var currentPath = window.location.pathname;
    if (currentHost === 'meshinspector.github.io' && !currentPath.includes('/MeshLib/dev/')) {
      var newPath = currentPath.replace('/MeshLib/html', '/documentation');
      var newURL = 'https://meshlib.io' + newPath + window.location.search + window.location.hash;
      window.location.replace(newURL);
    }
  }();
</script>
<script>
  !function(){var i="analytics",analytics=window[i]=window[i]||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","screen","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware","register"];analytics.factory=function(e){return function(){if(window[i].initialized)return window[i][e].apply(window[i],arguments);var n=Array.prototype.slice.call(arguments);if(["track","screen","alias","group","page","identify"].indexOf(e)>-1){var c=document.querySelector("link[rel='canonical']");n.push({__t:"bpc",c:c&&c.getAttribute("href")||void 0,p:location.pathname,u:location.href,s:location.search,t:document.title,r:document.referrer})}n.unshift(e);analytics.push(n);return analytics}};for(var n=0;n<analytics.methods.length;n++){var key=analytics.methods[n];analytics[key]=analytics.factory(key)}analytics.load=function(key,n){var t=document.createElement("script");t.type="text/javascript";t.async=!0;t.setAttribute("data-global-segment-analytics-key",i);t.src="https://cdn.segment.com/analytics.js/v1/" + key + "/analytics.min.js";var r=document.getElementsByTagName("script")[0];r.parentNode.insertBefore(t,r);analytics._loadOptions=n};analytics._writeKey="Fi7y6F1GgFvTTomYo8zvETBoGHkDDxGx";;analytics.SNIPPET_VERSION="5.2.0";
  analytics.load("Fi7y6F1GgFvTTomYo8zvETBoGHkDDxGx");
  analytics.page();
  }}();
</script>
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-MBPLX27B');</script>
  <!-- End Google Tag Manager -->
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshLib Documentation: MR::Mesh Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CustomStyle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
    DoxygenAwesomeTabs.init()
</script>
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MBPLX27B"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="favicon.ico"/></td>
  <td id="projectalign">
   <div id="projectname">MeshLib Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structMR_1_1Mesh.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structMR_1_1Mesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MR::Mesh Struct Reference<div class="ingroups"><a class="el" href="group__MeshGroup.html">Mesh</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="MRMesh_2MRMesh_8h_source.html">MRMesh.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a994943959e77b3bc34449639c1dfcb6f" id="r_a994943959e77b3bc34449639c1dfcb6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a994943959e77b3bc34449639c1dfcb6f">operator==</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;b) const</td></tr>
<tr class="memdesc:a994943959e77b3bc34449639c1dfcb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare that two meshes are exactly the same  <br /></td></tr>
<tr class="separator:a994943959e77b3bc34449639c1dfcb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fab8c28312fa8c3ac69c2f63d345f20" id="r_a5fab8c28312fa8c3ac69c2f63d345f20"><td class="memItemLeft" align="right" valign="top">Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fab8c28312fa8c3ac69c2f63d345f20">orgPnt</a> (EdgeId e) const</td></tr>
<tr class="memdesc:a5fab8c28312fa8c3ac69c2f63d345f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns coordinates of the edge origin  <br /></td></tr>
<tr class="separator:a5fab8c28312fa8c3ac69c2f63d345f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6241859f835aa7cd22f26c1e40b9791a" id="r_a6241859f835aa7cd22f26c1e40b9791a"><td class="memItemLeft" align="right" valign="top">Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6241859f835aa7cd22f26c1e40b9791a">destPnt</a> (EdgeId e) const</td></tr>
<tr class="memdesc:a6241859f835aa7cd22f26c1e40b9791a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns coordinates of the edge destination  <br /></td></tr>
<tr class="separator:a6241859f835aa7cd22f26c1e40b9791a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19223c76e1742c8cf6a56fd51b5c2c68" id="r_a19223c76e1742c8cf6a56fd51b5c2c68"><td class="memItemLeft" align="right" valign="top">Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19223c76e1742c8cf6a56fd51b5c2c68">edgeVector</a> (EdgeId e) const</td></tr>
<tr class="memdesc:a19223c76e1742c8cf6a56fd51b5c2c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns vector equal to edge destination point minus edge origin point  <br /></td></tr>
<tr class="separator:a19223c76e1742c8cf6a56fd51b5c2c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840bac6e56b6be19515df2d1a3cf69fd" id="r_a840bac6e56b6be19515df2d1a3cf69fd"><td class="memItemLeft" align="right" valign="top">LineSegm3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a840bac6e56b6be19515df2d1a3cf69fd">edgeSegment</a> (EdgeId e) const</td></tr>
<tr class="memdesc:a840bac6e56b6be19515df2d1a3cf69fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns line segment of given edge  <br /></td></tr>
<tr class="separator:a840bac6e56b6be19515df2d1a3cf69fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584a6ede1ccbc7e9568e03eb8abd4ed5" id="r_a584a6ede1ccbc7e9568e03eb8abd4ed5"><td class="memItemLeft" align="right" valign="top">Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a584a6ede1ccbc7e9568e03eb8abd4ed5">edgePoint</a> (EdgeId e, float f) const</td></tr>
<tr class="memdesc:a584a6ede1ccbc7e9568e03eb8abd4ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a point on the edge: origin point for f=0 and destination point for f=1  <br /></td></tr>
<tr class="separator:a584a6ede1ccbc7e9568e03eb8abd4ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbd41edd56e7e2c65589e9d7b0687fa" id="r_abdbd41edd56e7e2c65589e9d7b0687fa"><td class="memItemLeft" align="right" valign="top">Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdbd41edd56e7e2c65589e9d7b0687fa">edgePoint</a> (const <a class="el" href="namespaceMR.html#a8ffb37085bbd6060f17bcf222941ab8c">MeshEdgePoint</a> &amp;ep) const</td></tr>
<tr class="memdesc:abdbd41edd56e7e2c65589e9d7b0687fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes coordinates of point given as edge and relative position on it  <br /></td></tr>
<tr class="separator:abdbd41edd56e7e2c65589e9d7b0687fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45947ba454ab92f4c8bacbcd94b17f4" id="r_ad45947ba454ab92f4c8bacbcd94b17f4"><td class="memItemLeft" align="right" valign="top">Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad45947ba454ab92f4c8bacbcd94b17f4">edgeCenter</a> (UndirectedEdgeId e) const</td></tr>
<tr class="memdesc:ad45947ba454ab92f4c8bacbcd94b17f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the center of given edge  <br /></td></tr>
<tr class="separator:ad45947ba454ab92f4c8bacbcd94b17f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d51b4057ba3a41c5ef11fba53fa8a3c" id="r_a7d51b4057ba3a41c5ef11fba53fa8a3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d51b4057ba3a41c5ef11fba53fa8a3c">getLeftTriPoints</a> (EdgeId e, Vector3f &amp;v0, Vector3f &amp;v1, Vector3f &amp;v2) const</td></tr>
<tr class="memdesc:a7d51b4057ba3a41c5ef11fba53fa8a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns three points of left face of e  <br /></td></tr>
<tr class="separator:a7d51b4057ba3a41c5ef11fba53fa8a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c5a975cbd95ff470346d693287bb5d" id="r_af1c5a975cbd95ff470346d693287bb5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1c5a975cbd95ff470346d693287bb5d">getLeftTriPoints</a> (EdgeId e, Vector3f(&amp;v)[3]) const</td></tr>
<tr class="memdesc:af1c5a975cbd95ff470346d693287bb5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns three points of left face of e  <br /></td></tr>
<tr class="separator:af1c5a975cbd95ff470346d693287bb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7173fafd19150c40259003561a02162a" id="r_a7173fafd19150c40259003561a02162a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMR.html#ac3b4f93ff16dbb5975ce8dec6adc39cf">Triangle3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7173fafd19150c40259003561a02162a">getLeftTriPoints</a> (EdgeId e) const</td></tr>
<tr class="memdesc:a7173fafd19150c40259003561a02162a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns three points of left face of e  <br /></td></tr>
<tr class="separator:a7173fafd19150c40259003561a02162a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe211d973521963165b09ad25d9a971c" id="r_abe211d973521963165b09ad25d9a971c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe211d973521963165b09ad25d9a971c">getTriPoints</a> (FaceId f, Vector3f &amp;v0, Vector3f &amp;v1, Vector3f &amp;v2) const</td></tr>
<tr class="memdesc:abe211d973521963165b09ad25d9a971c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns three points of given face  <br /></td></tr>
<tr class="separator:abe211d973521963165b09ad25d9a971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe28c0649ca99c11e22e99fcce026ffe" id="r_abe28c0649ca99c11e22e99fcce026ffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe28c0649ca99c11e22e99fcce026ffe">getTriPoints</a> (FaceId f, Vector3f(&amp;v)[3]) const</td></tr>
<tr class="memdesc:abe28c0649ca99c11e22e99fcce026ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns three points of given face  <br /></td></tr>
<tr class="separator:abe28c0649ca99c11e22e99fcce026ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a31eccbae1dd87a464a0907aad14ce" id="r_a55a31eccbae1dd87a464a0907aad14ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMR.html#ac3b4f93ff16dbb5975ce8dec6adc39cf">Triangle3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55a31eccbae1dd87a464a0907aad14ce">getTriPoints</a> (FaceId f) const</td></tr>
<tr class="memdesc:a55a31eccbae1dd87a464a0907aad14ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns three points of given face  <br /></td></tr>
<tr class="separator:a55a31eccbae1dd87a464a0907aad14ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243ed2368ebb1f7bfaa1d71cef8a3d16" id="r_a243ed2368ebb1f7bfaa1d71cef8a3d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a243ed2368ebb1f7bfaa1d71cef8a3d16">triPoint</a> (const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;p) const</td></tr>
<tr class="memdesc:a243ed2368ebb1f7bfaa1d71cef8a3d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes coordinates of point given as face and barycentric representation  <br /></td></tr>
<tr class="separator:a243ed2368ebb1f7bfaa1d71cef8a3d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc962b114f068665a1f40c936f26724" id="r_a9fc962b114f068665a1f40c936f26724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fc962b114f068665a1f40c936f26724">triCenter</a> (FaceId f) const</td></tr>
<tr class="memdesc:a9fc962b114f068665a1f40c936f26724"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the centroid of given triangle  <br /></td></tr>
<tr class="separator:a9fc962b114f068665a1f40c936f26724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f7db0c7ecd59955478746c13609ff6" id="r_a49f7db0c7ecd59955478746c13609ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49f7db0c7ecd59955478746c13609ff6">triangleAspectRatio</a> (FaceId f) const</td></tr>
<tr class="memdesc:a49f7db0c7ecd59955478746c13609ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns aspect ratio of given mesh triangle equal to the ratio of the circum-radius to twice its in-radius  <br /></td></tr>
<tr class="separator:a49f7db0c7ecd59955478746c13609ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739c01f192fc474add3f5341ade42018" id="r_a739c01f192fc474add3f5341ade42018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a739c01f192fc474add3f5341ade42018">circumcircleDiameterSq</a> (FaceId f) const</td></tr>
<tr class="memdesc:a739c01f192fc474add3f5341ade42018"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns squared circumcircle diameter of given mesh triangle  <br /></td></tr>
<tr class="separator:a739c01f192fc474add3f5341ade42018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c995113408ff1e1911197ea23564987" id="r_a9c995113408ff1e1911197ea23564987"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c995113408ff1e1911197ea23564987">circumcircleDiameter</a> (FaceId f) const</td></tr>
<tr class="memdesc:a9c995113408ff1e1911197ea23564987"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns circumcircle diameter of given mesh triangle  <br /></td></tr>
<tr class="separator:a9c995113408ff1e1911197ea23564987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d99831d2f44ba34b7678c921475088" id="r_a25d99831d2f44ba34b7678c921475088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25d99831d2f44ba34b7678c921475088">toTriPoint</a> (VertId v) const</td></tr>
<tr class="memdesc:a25d99831d2f44ba34b7678c921475088"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts vertex into barycentric representation  <br /></td></tr>
<tr class="separator:a25d99831d2f44ba34b7678c921475088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3275b6e90cf7c761fd228b9bc6fefeb" id="r_ab3275b6e90cf7c761fd228b9bc6fefeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3275b6e90cf7c761fd228b9bc6fefeb">toTriPoint</a> (FaceId f, const Vector3f &amp;p) const</td></tr>
<tr class="memdesc:ab3275b6e90cf7c761fd228b9bc6fefeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts face id and 3d point into barycentric representation  <br /></td></tr>
<tr class="separator:ab3275b6e90cf7c761fd228b9bc6fefeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ce30cba5543afc4736d287bfd3d3bc" id="r_a98ce30cba5543afc4736d287bfd3d3bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98ce30cba5543afc4736d287bfd3d3bc">toTriPoint</a> (const <a class="el" href="structMR_1_1PointOnFace.html">PointOnFace</a> &amp;p) const</td></tr>
<tr class="memdesc:a98ce30cba5543afc4736d287bfd3d3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts face id and 3d point into barycentric representation  <br /></td></tr>
<tr class="separator:a98ce30cba5543afc4736d287bfd3d3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7ed762df9371522b37dc2b15689234" id="r_add7ed762df9371522b37dc2b15689234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a8ffb37085bbd6060f17bcf222941ab8c">MeshEdgePoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add7ed762df9371522b37dc2b15689234">toEdgePoint</a> (VertId v) const</td></tr>
<tr class="memdesc:add7ed762df9371522b37dc2b15689234"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts vertex into edge-point representation  <br /></td></tr>
<tr class="separator:add7ed762df9371522b37dc2b15689234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96011e8aa47330e9f075bc4ef3a08e2" id="r_aa96011e8aa47330e9f075bc4ef3a08e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a8ffb37085bbd6060f17bcf222941ab8c">MeshEdgePoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa96011e8aa47330e9f075bc4ef3a08e2">toEdgePoint</a> (EdgeId e, const Vector3f &amp;p) const</td></tr>
<tr class="memdesc:aa96011e8aa47330e9f075bc4ef3a08e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts edge and 3d point into edge-point representation  <br /></td></tr>
<tr class="separator:aa96011e8aa47330e9f075bc4ef3a08e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe5788ff7927b5a1b5f70b157353ab6" id="r_a4fe5788ff7927b5a1b5f70b157353ab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fe5788ff7927b5a1b5f70b157353ab6">getClosestVertex</a> (const <a class="el" href="structMR_1_1PointOnFace.html">PointOnFace</a> &amp;p) const</td></tr>
<tr class="memdesc:a4fe5788ff7927b5a1b5f70b157353ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns one of three face vertices, closest to given point  <br /></td></tr>
<tr class="separator:a4fe5788ff7927b5a1b5f70b157353ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e825f78e748198301ee280cbb88b9c" id="r_a08e825f78e748198301ee280cbb88b9c"><td class="memItemLeft" align="right" valign="top">VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08e825f78e748198301ee280cbb88b9c">getClosestVertex</a> (const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;p) const</td></tr>
<tr class="memdesc:a08e825f78e748198301ee280cbb88b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns one of three face vertices, closest to given point  <br /></td></tr>
<tr class="separator:a08e825f78e748198301ee280cbb88b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6db3be66aadef6658a7692c9181713" id="r_a1b6db3be66aadef6658a7692c9181713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> UndirectedEdgeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b6db3be66aadef6658a7692c9181713">getClosestEdge</a> (const <a class="el" href="structMR_1_1PointOnFace.html">PointOnFace</a> &amp;p) const</td></tr>
<tr class="memdesc:a1b6db3be66aadef6658a7692c9181713"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns one of three face edges, closest to given point  <br /></td></tr>
<tr class="separator:a1b6db3be66aadef6658a7692c9181713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c234ebc0fba018fda6c46a072d8089" id="r_a91c234ebc0fba018fda6c46a072d8089"><td class="memItemLeft" align="right" valign="top">UndirectedEdgeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91c234ebc0fba018fda6c46a072d8089">getClosestEdge</a> (const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;p) const</td></tr>
<tr class="memdesc:a91c234ebc0fba018fda6c46a072d8089"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns one of three face edges, closest to given point  <br /></td></tr>
<tr class="separator:a91c234ebc0fba018fda6c46a072d8089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad741164ba566adeb2830a4de3861bfd0" id="r_ad741164ba566adeb2830a4de3861bfd0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad741164ba566adeb2830a4de3861bfd0">edgeLength</a> (UndirectedEdgeId e) const</td></tr>
<tr class="memdesc:ad741164ba566adeb2830a4de3861bfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns Euclidean length of the edge  <br /></td></tr>
<tr class="separator:ad741164ba566adeb2830a4de3861bfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dda7695db1d721bc3cb64bb374c89c4" id="r_a4dda7695db1d721bc3cb64bb374c89c4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dda7695db1d721bc3cb64bb374c89c4">edgeLengthSq</a> (UndirectedEdgeId e) const</td></tr>
<tr class="memdesc:a4dda7695db1d721bc3cb64bb374c89c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns squared Euclidean length of the edge (faster to compute than length)  <br /></td></tr>
<tr class="separator:a4dda7695db1d721bc3cb64bb374c89c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfefd886da876ca72f2d96231206ed43" id="r_acfefd886da876ca72f2d96231206ed43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfefd886da876ca72f2d96231206ed43">leftDirDblArea</a> (EdgeId e) const</td></tr>
<tr class="memdesc:acfefd886da876ca72f2d96231206ed43"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes directed double area of left triangular face of given edge  <br /></td></tr>
<tr class="separator:acfefd886da876ca72f2d96231206ed43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3563494ce9b9a0cf5a7e4346606961" id="r_afd3563494ce9b9a0cf5a7e4346606961"><td class="memItemLeft" align="right" valign="top">Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd3563494ce9b9a0cf5a7e4346606961">dirDblArea</a> (FaceId f) const</td></tr>
<tr class="memdesc:afd3563494ce9b9a0cf5a7e4346606961"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes directed double area for a triangular face from its vertices  <br /></td></tr>
<tr class="separator:afd3563494ce9b9a0cf5a7e4346606961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2a8eaf7d1882e02a3eea66d1d72349" id="r_a1e2a8eaf7d1882e02a3eea66d1d72349"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e2a8eaf7d1882e02a3eea66d1d72349">dblArea</a> (FaceId f) const</td></tr>
<tr class="memdesc:a1e2a8eaf7d1882e02a3eea66d1d72349"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns twice the area of given face  <br /></td></tr>
<tr class="separator:a1e2a8eaf7d1882e02a3eea66d1d72349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03632276528ce953490a2111a5280c7c" id="r_a03632276528ce953490a2111a5280c7c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03632276528ce953490a2111a5280c7c">area</a> (FaceId f) const</td></tr>
<tr class="memdesc:a03632276528ce953490a2111a5280c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the area of given face  <br /></td></tr>
<tr class="separator:a03632276528ce953490a2111a5280c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c83a5a324f80a18969d786febaee653" id="r_a0c83a5a324f80a18969d786febaee653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c83a5a324f80a18969d786febaee653">area</a> (const FaceBitSet &amp;fs) const</td></tr>
<tr class="memdesc:a0c83a5a324f80a18969d786febaee653"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the area of given face-region  <br /></td></tr>
<tr class="separator:a0c83a5a324f80a18969d786febaee653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cc8a4868a2671492e010d86cb408cd" id="r_a45cc8a4868a2671492e010d86cb408cd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45cc8a4868a2671492e010d86cb408cd">area</a> (const FaceBitSet *fs=nullptr) const</td></tr>
<tr class="memdesc:a45cc8a4868a2671492e010d86cb408cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the area of given face-region (or whole mesh)  <br /></td></tr>
<tr class="separator:a45cc8a4868a2671492e010d86cb408cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2049ae64855f1b9d7c6da0d946faa3" id="r_a1d2049ae64855f1b9d7c6da0d946faa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d2049ae64855f1b9d7c6da0d946faa3">dirArea</a> (const FaceBitSet &amp;fs) const</td></tr>
<tr class="memdesc:a1d2049ae64855f1b9d7c6da0d946faa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the sum of directed areas for faces from given region  <br /></td></tr>
<tr class="separator:a1d2049ae64855f1b9d7c6da0d946faa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029d8d453e90f13a14ae22b25a71db47" id="r_a029d8d453e90f13a14ae22b25a71db47"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a029d8d453e90f13a14ae22b25a71db47">dirArea</a> (const FaceBitSet *fs=nullptr) const</td></tr>
<tr class="memdesc:a029d8d453e90f13a14ae22b25a71db47"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the sum of directed areas for faces from given region (or whole mesh)  <br /></td></tr>
<tr class="separator:a029d8d453e90f13a14ae22b25a71db47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6410490732e1756a5716df6539c55d45" id="r_a6410490732e1756a5716df6539c55d45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6410490732e1756a5716df6539c55d45">projArea</a> (const Vector3f &amp;dir, const FaceBitSet &amp;fs) const</td></tr>
<tr class="memdesc:a6410490732e1756a5716df6539c55d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the sum of absolute projected area of faces from given region as visible if look from given direction  <br /></td></tr>
<tr class="separator:a6410490732e1756a5716df6539c55d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a7cadb50ed558293082e1da4bb24f2" id="r_af4a7cadb50ed558293082e1da4bb24f2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4a7cadb50ed558293082e1da4bb24f2">projArea</a> (const Vector3f &amp;dir, const FaceBitSet *fs=nullptr) const</td></tr>
<tr class="memdesc:af4a7cadb50ed558293082e1da4bb24f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the sum of absolute projected area of faces from given region (or whole mesh) as visible if look from given direction  <br /></td></tr>
<tr class="separator:af4a7cadb50ed558293082e1da4bb24f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952176d5bcd16b91d26dc6fa2a0bdc6c" id="r_a952176d5bcd16b91d26dc6fa2a0bdc6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a952176d5bcd16b91d26dc6fa2a0bdc6c">volume</a> (const FaceBitSet *region=nullptr) const</td></tr>
<tr class="separator:a952176d5bcd16b91d26dc6fa2a0bdc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fca747ad4dc619010b3f7dbb857f86" id="r_af3fca747ad4dc619010b3f7dbb857f86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3fca747ad4dc619010b3f7dbb857f86">holePerimiter</a> (EdgeId e) const</td></tr>
<tr class="memdesc:af3fca747ad4dc619010b3f7dbb857f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the perimeter of the hole specified by one of its edges with no valid left face (left is hole)  <br /></td></tr>
<tr class="separator:af3fca747ad4dc619010b3f7dbb857f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb26b3e42dbd2a5418b461add1d9f57" id="r_addb26b3e42dbd2a5418b461add1d9f57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addb26b3e42dbd2a5418b461add1d9f57">holeDirArea</a> (EdgeId e) const</td></tr>
<tr class="separator:addb26b3e42dbd2a5418b461add1d9f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797623a41864029eb93103c262fa70d4" id="r_a797623a41864029eb93103c262fa70d4"><td class="memItemLeft" align="right" valign="top">Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a797623a41864029eb93103c262fa70d4">leftNormal</a> (EdgeId e) const</td></tr>
<tr class="memdesc:a797623a41864029eb93103c262fa70d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes triangular face normal from its vertices  <br /></td></tr>
<tr class="separator:a797623a41864029eb93103c262fa70d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0ceb8ed258ca42cf125638c6940594" id="r_acc0ceb8ed258ca42cf125638c6940594"><td class="memItemLeft" align="right" valign="top">Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc0ceb8ed258ca42cf125638c6940594">normal</a> (FaceId f) const</td></tr>
<tr class="memdesc:acc0ceb8ed258ca42cf125638c6940594"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes triangular face normal from its vertices  <br /></td></tr>
<tr class="separator:acc0ceb8ed258ca42cf125638c6940594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4237bb2ee8edbc72aa4189bc2307a544" id="r_a4237bb2ee8edbc72aa4189bc2307a544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4237bb2ee8edbc72aa4189bc2307a544">dirDblArea</a> (VertId v) const</td></tr>
<tr class="memdesc:a4237bb2ee8edbc72aa4189bc2307a544"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes sum of directed double areas of all triangles around given vertex  <br /></td></tr>
<tr class="separator:a4237bb2ee8edbc72aa4189bc2307a544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d39814aa495e12ba8e388c22a6f12e" id="r_ab6d39814aa495e12ba8e388c22a6f12e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d39814aa495e12ba8e388c22a6f12e">dblArea</a> (VertId v) const</td></tr>
<tr class="memdesc:ab6d39814aa495e12ba8e388c22a6f12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the length of summed directed double areas of all triangles around given vertex  <br /></td></tr>
<tr class="separator:ab6d39814aa495e12ba8e388c22a6f12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff330955f978300560fd33b43cd77cdd" id="r_aff330955f978300560fd33b43cd77cdd"><td class="memItemLeft" align="right" valign="top">Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff330955f978300560fd33b43cd77cdd">normal</a> (VertId v) const</td></tr>
<tr class="memdesc:aff330955f978300560fd33b43cd77cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes normal in a vertex using sum of directed areas of neighboring triangles  <br /></td></tr>
<tr class="separator:aff330955f978300560fd33b43cd77cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc20c6104570ee76cffee01e1ea9aa0" id="r_a0bc20c6104570ee76cffee01e1ea9aa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bc20c6104570ee76cffee01e1ea9aa0">normal</a> (const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;p) const</td></tr>
<tr class="separator:a0bc20c6104570ee76cffee01e1ea9aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0764fd9acf9f3a4b060a658c656efc" id="r_a3f0764fd9acf9f3a4b060a658c656efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f0764fd9acf9f3a4b060a658c656efc">pseudonormal</a> (VertId v, const FaceBitSet *region=nullptr) const</td></tr>
<tr class="separator:a3f0764fd9acf9f3a4b060a658c656efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d264981ad277abb011e94a67cd5e4e" id="r_a33d264981ad277abb011e94a67cd5e4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33d264981ad277abb011e94a67cd5e4e">pseudonormal</a> (UndirectedEdgeId e, const FaceBitSet *region=nullptr) const</td></tr>
<tr class="memdesc:a33d264981ad277abb011e94a67cd5e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes normalized half sum of face normals sharing given edge (only (region) faces will be considered);  <br /></td></tr>
<tr class="separator:a33d264981ad277abb011e94a67cd5e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada333ee4f3b0edfa859e5f8ee5a1c1f1" id="r_ada333ee4f3b0edfa859e5f8ee5a1c1f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada333ee4f3b0edfa859e5f8ee5a1c1f1">pseudonormal</a> (const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;p, const FaceBitSet *region=nullptr) const</td></tr>
<tr class="separator:ada333ee4f3b0edfa859e5f8ee5a1c1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0095216b1fbe49128eb4b14d6c9f8a42" id="r_a0095216b1fbe49128eb4b14d6c9f8a42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0095216b1fbe49128eb4b14d6c9f8a42">signedDistance</a> (const Vector3f &amp;pt, const <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;proj, const FaceBitSet *region=nullptr) const</td></tr>
<tr class="separator:a0095216b1fbe49128eb4b14d6c9f8a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24304bcd9afe5cdb84be4ee761a8fb2f" id="r_a24304bcd9afe5cdb84be4ee761a8fb2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24304bcd9afe5cdb84be4ee761a8fb2f">signedDistance</a> (const Vector3f &amp;pt, const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;proj, const FaceBitSet *region=nullptr) const</td></tr>
<tr class="separator:a24304bcd9afe5cdb84be4ee761a8fb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879abd4325e74e6c17acebe255877c83" id="r_a879abd4325e74e6c17acebe255877c83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a879abd4325e74e6c17acebe255877c83">signedDistance</a> (const Vector3f &amp;pt) const</td></tr>
<tr class="separator:a879abd4325e74e6c17acebe255877c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4048484ac2e78090960bc9bbc60cd6b6" id="r_a4048484ac2e78090960bc9bbc60cd6b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4048484ac2e78090960bc9bbc60cd6b6">signedDistance</a> (const Vector3f &amp;pt, float maxDistSq, const FaceBitSet *region=nullptr) const</td></tr>
<tr class="separator:a4048484ac2e78090960bc9bbc60cd6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddf4af17627f59df39990e32ea87c04" id="r_a0ddf4af17627f59df39990e32ea87c04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ddf4af17627f59df39990e32ea87c04">calcFastWindingNumber</a> (const Vector3f &amp;pt, float beta=2) const</td></tr>
<tr class="separator:a0ddf4af17627f59df39990e32ea87c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8121a87b4511118c273836888eb18ab8" id="r_a8121a87b4511118c273836888eb18ab8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8121a87b4511118c273836888eb18ab8">isOutside</a> (const Vector3f &amp;pt, float windingNumberThreshold=0.5f, float beta=2) const</td></tr>
<tr class="separator:a8121a87b4511118c273836888eb18ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdc9e5969b065b761018ff5cb0a43a5" id="r_a0fdc9e5969b065b761018ff5cb0a43a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fdc9e5969b065b761018ff5cb0a43a5">isOutsideByProjNorm</a> (const Vector3f &amp;pt, const <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;proj, const FaceBitSet *region=nullptr) const</td></tr>
<tr class="separator:a0fdc9e5969b065b761018ff5cb0a43a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9168ca386aa3a34b0c1b79ddd7f4faa3" id="r_a9168ca386aa3a34b0c1b79ddd7f4faa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9168ca386aa3a34b0c1b79ddd7f4faa3">sumAngles</a> (VertId v, bool *outBoundaryVert=nullptr) const</td></tr>
<tr class="memdesc:a9168ca386aa3a34b0c1b79ddd7f4faa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the sum of triangle angles at given vertex; optionally returns whether the vertex is on boundary  <br /></td></tr>
<tr class="separator:a9168ca386aa3a34b0c1b79ddd7f4faa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63974f1e9e91aec82c60fc776f51ea7b" id="r_a63974f1e9e91aec82c60fc776f51ea7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; VertBitSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63974f1e9e91aec82c60fc776f51ea7b">findSpikeVertices</a> (float minSumAngle, const VertBitSet *region=nullptr, <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> cb={}) const</td></tr>
<tr class="memdesc:a63974f1e9e91aec82c60fc776f51ea7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns vertices where the sum of triangle angles is below given threshold  <br /></td></tr>
<tr class="separator:a63974f1e9e91aec82c60fc776f51ea7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a599e9255943ae4fab5935502d2f21" id="r_a08a599e9255943ae4fab5935502d2f21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08a599e9255943ae4fab5935502d2f21">dihedralAngleSin</a> (UndirectedEdgeId e) const</td></tr>
<tr class="separator:a08a599e9255943ae4fab5935502d2f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc9fe4f12054a0171667825056fe457" id="r_afbc9fe4f12054a0171667825056fe457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbc9fe4f12054a0171667825056fe457">dihedralAngleCos</a> (UndirectedEdgeId e) const</td></tr>
<tr class="separator:afbc9fe4f12054a0171667825056fe457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938d6bd536f16b6f46394ceb91271053" id="r_a938d6bd536f16b6f46394ceb91271053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a938d6bd536f16b6f46394ceb91271053">dihedralAngle</a> (UndirectedEdgeId e) const</td></tr>
<tr class="separator:a938d6bd536f16b6f46394ceb91271053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab555df576a4de372990fabcac596979f" id="r_ab555df576a4de372990fabcac596979f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab555df576a4de372990fabcac596979f">discreteMeanCurvature</a> (VertId v) const</td></tr>
<tr class="separator:ab555df576a4de372990fabcac596979f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85462881d0758cd78deba62d9bbc416" id="r_ad85462881d0758cd78deba62d9bbc416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad85462881d0758cd78deba62d9bbc416">discreteMeanCurvature</a> (UndirectedEdgeId e) const</td></tr>
<tr class="separator:ad85462881d0758cd78deba62d9bbc416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e24b802c039dde02eeb902045cdb20" id="r_a18e24b802c039dde02eeb902045cdb20"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18e24b802c039dde02eeb902045cdb20">discreteGaussianCurvature</a> (VertId v, bool *outBoundaryVert=nullptr) const</td></tr>
<tr class="separator:a18e24b802c039dde02eeb902045cdb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3597555fee6f4964fe1689b0643f7f83" id="r_a3597555fee6f4964fe1689b0643f7f83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> UndirectedEdgeBitSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3597555fee6f4964fe1689b0643f7f83">findCreaseEdges</a> (float angleFromPlanar) const</td></tr>
<tr class="memdesc:a3597555fee6f4964fe1689b0643f7f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all mesh edges where dihedral angle is distinct from planar PI angle on at least given value  <br /></td></tr>
<tr class="separator:a3597555fee6f4964fe1689b0643f7f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa347e7c284659d13d5e9ef0df1a52d5e" id="r_aa347e7c284659d13d5e9ef0df1a52d5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa347e7c284659d13d5e9ef0df1a52d5e">leftCotan</a> (EdgeId e) const</td></tr>
<tr class="separator:aa347e7c284659d13d5e9ef0df1a52d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3794627367f1c0ae6a497f41542197" id="r_aae3794627367f1c0ae6a497f41542197"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae3794627367f1c0ae6a497f41542197">cotan</a> (UndirectedEdgeId ue) const</td></tr>
<tr class="separator:aae3794627367f1c0ae6a497f41542197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cb7cda413178e311cd23632d44a07f" id="r_aa0cb7cda413178e311cd23632d44a07f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> QuadraticForm3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0cb7cda413178e311cd23632d44a07f">quadraticForm</a> (VertId v, const FaceBitSet *region=nullptr, const UndirectedEdgeBitSet *creases=nullptr) const</td></tr>
<tr class="separator:aa0cb7cda413178e311cd23632d44a07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30783b277e8cd9daed4827c15daede28" id="r_a30783b277e8cd9daed4827c15daede28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Box3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30783b277e8cd9daed4827c15daede28">computeBoundingBox</a> (const AffineXf3f *toWorld=nullptr) const</td></tr>
<tr class="separator:a30783b277e8cd9daed4827c15daede28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9114dc0640fc079b18e83625c3464a" id="r_a6a9114dc0640fc079b18e83625c3464a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Box3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a9114dc0640fc079b18e83625c3464a">getBoundingBox</a> () const</td></tr>
<tr class="separator:a6a9114dc0640fc079b18e83625c3464a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091677e4ef6993ac15490326ebcc1c78" id="r_a091677e4ef6993ac15490326ebcc1c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Box3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a091677e4ef6993ac15490326ebcc1c78">computeBoundingBox</a> (const FaceBitSet *region, const AffineXf3f *toWorld=nullptr) const</td></tr>
<tr class="separator:a091677e4ef6993ac15490326ebcc1c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0fa1663015706fa78dc52fe840b4a9" id="r_ace0fa1663015706fa78dc52fe840b4a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace0fa1663015706fa78dc52fe840b4a9">averageEdgeLength</a> () const</td></tr>
<tr class="memdesc:ace0fa1663015706fa78dc52fe840b4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes average length of an edge in this mesh  <br /></td></tr>
<tr class="separator:ace0fa1663015706fa78dc52fe840b4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf526a36b567b3e072c3aa70d628ee2" id="r_a4cf526a36b567b3e072c3aa70d628ee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cf526a36b567b3e072c3aa70d628ee2">findCenterFromPoints</a> () const</td></tr>
<tr class="memdesc:a4cf526a36b567b3e072c3aa70d628ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes average position of all valid mesh vertices  <br /></td></tr>
<tr class="separator:a4cf526a36b567b3e072c3aa70d628ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1576164a9505c9f8c28e16dc288bcca9" id="r_a1576164a9505c9f8c28e16dc288bcca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1576164a9505c9f8c28e16dc288bcca9">findCenterFromFaces</a> () const</td></tr>
<tr class="memdesc:a1576164a9505c9f8c28e16dc288bcca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes center of mass considering that density of all triangles is the same  <br /></td></tr>
<tr class="separator:a1576164a9505c9f8c28e16dc288bcca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef2784fa43035776fad3e85ac252642" id="r_a7ef2784fa43035776fad3e85ac252642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ef2784fa43035776fad3e85ac252642">findCenterFromBBox</a> () const</td></tr>
<tr class="memdesc:a7ef2784fa43035776fad3e85ac252642"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bounding box and returns its center  <br /></td></tr>
<tr class="separator:a7ef2784fa43035776fad3e85ac252642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540a6eef456f6c54c214766fc0a7c3fb" id="r_a540a6eef456f6c54c214766fc0a7c3fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a540a6eef456f6c54c214766fc0a7c3fb">zeroUnusedPoints</a> ()</td></tr>
<tr class="memdesc:a540a6eef456f6c54c214766fc0a7c3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">for all points not in topology.getValidVerts() sets coordinates to (0,0,0)  <br /></td></tr>
<tr class="separator:a540a6eef456f6c54c214766fc0a7c3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9295908f703adbacd9b9b8f900b85f7d" id="r_a9295908f703adbacd9b9b8f900b85f7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9295908f703adbacd9b9b8f900b85f7d">transform</a> (const AffineXf3f &amp;xf, const VertBitSet *region=nullptr)</td></tr>
<tr class="separator:a9295908f703adbacd9b9b8f900b85f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee64892c6401f2ffc0394a59628cdbb5" id="r_aee64892c6401f2ffc0394a59628cdbb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee64892c6401f2ffc0394a59628cdbb5">addPoint</a> (const Vector3f &amp;pos)</td></tr>
<tr class="memdesc:aee64892c6401f2ffc0394a59628cdbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates new point and assigns given position to it  <br /></td></tr>
<tr class="separator:aee64892c6401f2ffc0394a59628cdbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe79fbba41c13a31bd40b10fdff8b5ee" id="r_afe79fbba41c13a31bd40b10fdff8b5ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe79fbba41c13a31bd40b10fdff8b5ee">addSeparateEdgeLoop</a> (const std::vector&lt; Vector3f &gt; &amp;contourPoints)</td></tr>
<tr class="separator:afe79fbba41c13a31bd40b10fdff8b5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8119f3200435e62435f6ec375d98c1" id="r_abd8119f3200435e62435f6ec375d98c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd8119f3200435e62435f6ec375d98c1">addSeparateContours</a> (const <a class="el" href="namespaceMR.html#ac93791b17f5bb1ff4a6a7e7f51a7abc9">Contours3f</a> &amp;contours, const AffineXf3f *xf=nullptr)</td></tr>
<tr class="separator:abd8119f3200435e62435f6ec375d98c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab2d759266b7e751ef91845d21afd98" id="r_abab2d759266b7e751ef91845d21afd98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abab2d759266b7e751ef91845d21afd98">attachEdgeLoopPart</a> (EdgeId first, EdgeId last, const std::vector&lt; Vector3f &gt; &amp;contourPoints)</td></tr>
<tr class="separator:abab2d759266b7e751ef91845d21afd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7444cb052e8855eb1ea69b34d2796f3a" id="r_a7444cb052e8855eb1ea69b34d2796f3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7444cb052e8855eb1ea69b34d2796f3a">splitEdge</a> (EdgeId e, const Vector3f &amp;newVertPos, FaceBitSet *region=nullptr, <a class="el" href="namespaceMR.html#a93482f559c684be16c718d5acd291d3e">FaceHashMap</a> *new2Old=nullptr)</td></tr>
<tr class="separator:a7444cb052e8855eb1ea69b34d2796f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572820417c5fc8e867bbb2f078275222" id="r_a572820417c5fc8e867bbb2f078275222"><td class="memItemLeft" align="right" valign="top">EdgeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a572820417c5fc8e867bbb2f078275222">splitEdge</a> (EdgeId e, FaceBitSet *region=nullptr, <a class="el" href="namespaceMR.html#a93482f559c684be16c718d5acd291d3e">FaceHashMap</a> *new2Old=nullptr)</td></tr>
<tr class="separator:a572820417c5fc8e867bbb2f078275222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4678592f5a58aba37a0994f895ff7804" id="r_a4678592f5a58aba37a0994f895ff7804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4678592f5a58aba37a0994f895ff7804">splitFace</a> (FaceId f, const Vector3f &amp;newVertPos, FaceBitSet *region=nullptr, <a class="el" href="namespaceMR.html#a93482f559c684be16c718d5acd291d3e">FaceHashMap</a> *new2Old=nullptr)</td></tr>
<tr class="separator:a4678592f5a58aba37a0994f895ff7804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0879122a6abf7e015c89fdbd7dd584" id="r_a8c0879122a6abf7e015c89fdbd7dd584"><td class="memItemLeft" align="right" valign="top">VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c0879122a6abf7e015c89fdbd7dd584">splitFace</a> (FaceId f, FaceBitSet *region=nullptr, <a class="el" href="namespaceMR.html#a93482f559c684be16c718d5acd291d3e">FaceHashMap</a> *new2Old=nullptr)</td></tr>
<tr class="separator:a8c0879122a6abf7e015c89fdbd7dd584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceec437a01ce063998c0f63f339f246" id="r_a8ceec437a01ce063998c0f63f339f246"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ceec437a01ce063998c0f63f339f246">addPart</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;from, FaceMap *outFmap=nullptr, VertMap *outVmap=nullptr, WholeEdgeMap *outEmap=nullptr, bool rearrangeTriangles=false)</td></tr>
<tr class="memdesc:a8ceec437a01ce063998c0f63f339f246"><td class="mdescLeft">&#160;</td><td class="mdescRight">appends mesh (from) in addition to this mesh: creates new edges, faces, verts and points  <br /></td></tr>
<tr class="separator:a8ceec437a01ce063998c0f63f339f246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fb0761925dbb24dbb414e74fd881bc" id="r_ae5fb0761925dbb24dbb414e74fd881bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5fb0761925dbb24dbb414e74fd881bc">addPartByMask</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;from, const FaceBitSet &amp;fromFaces, const <a class="el" href="structMR_1_1PartMapping.html">PartMapping</a> &amp;map)</td></tr>
<tr class="memdesc:ae5fb0761925dbb24dbb414e74fd881bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">the same but copies only portion of (from) specified by fromFaces  <br /></td></tr>
<tr class="separator:ae5fb0761925dbb24dbb414e74fd881bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5686eed5d8d32c71c450f51644695a09" id="r_a5686eed5d8d32c71c450f51644695a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5686eed5d8d32c71c450f51644695a09">addPartByMask</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;from, const FaceBitSet &amp;fromFaces, bool flipOrientation=false, const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;thisContours={}, const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;fromContours={}, const <a class="el" href="structMR_1_1PartMapping.html">PartMapping</a> &amp;map={})</td></tr>
<tr class="separator:a5686eed5d8d32c71c450f51644695a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa14b4d2f6105806b0de757c0a87b7c" id="r_abfa14b4d2f6105806b0de757c0a87b7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfa14b4d2f6105806b0de757c0a87b7c">addPartByFaceMap</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;from, const FaceMap &amp;fromFaces, bool flipOrientation=false, const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;thisContours={}, const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;fromContours={}, const <a class="el" href="structMR_1_1PartMapping.html">PartMapping</a> &amp;map={})</td></tr>
<tr class="memdesc:abfa14b4d2f6105806b0de757c0a87b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">fromFaces contains mapping from this-mesh (considering it is empty) to from-mesh  <br /></td></tr>
<tr class="separator:abfa14b4d2f6105806b0de757c0a87b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a79f0f44fbbd679cff801144ef2df62" id="r_a3a79f0f44fbbd679cff801144ef2df62"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="namespaceMR.html#aae89e209e34f26d7ae6dcc7b5e7d2851">I</a> &gt; </td></tr>
<tr class="memitem:a3a79f0f44fbbd679cff801144ef2df62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a79f0f44fbbd679cff801144ef2df62">addPartBy</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;from, <a class="el" href="namespaceMR.html#aae89e209e34f26d7ae6dcc7b5e7d2851">I</a> fbegin, <a class="el" href="namespaceMR.html#aae89e209e34f26d7ae6dcc7b5e7d2851">I</a> fend, size_t fcount, bool flipOrientation=false, const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;thisContours={}, const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;fromContours={}, <a class="el" href="structMR_1_1PartMapping.html">PartMapping</a> map={})</td></tr>
<tr class="memdesc:a3a79f0f44fbbd679cff801144ef2df62"><td class="mdescLeft">&#160;</td><td class="mdescRight">both addPartByMask and addPartByFaceMap call this general implementation  <br /></td></tr>
<tr class="separator:a3a79f0f44fbbd679cff801144ef2df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9331e1cd987b8dab1bceac8a73c5f5" id="r_a2e9331e1cd987b8dab1bceac8a73c5f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e9331e1cd987b8dab1bceac8a73c5f5">cloneRegion</a> (const FaceBitSet &amp;region, bool flipOrientation=false, const <a class="el" href="structMR_1_1PartMapping.html">PartMapping</a> &amp;map={}) const</td></tr>
<tr class="memdesc:a2e9331e1cd987b8dab1bceac8a73c5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates new mesh from given triangles of this mesh  <br /></td></tr>
<tr class="separator:a2e9331e1cd987b8dab1bceac8a73c5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8e2d55d67e606f0129377d0d14aa4a" id="r_a6d8e2d55d67e606f0129377d0d14aa4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d8e2d55d67e606f0129377d0d14aa4a">pack</a> (FaceMap *outFmap=nullptr, VertMap *outVmap=nullptr, WholeEdgeMap *outEmap=nullptr, bool rearrangeTriangles=false)</td></tr>
<tr class="separator:a6d8e2d55d67e606f0129377d0d14aa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac790be9d7fbcbf9f765ebdd90f761c71" id="r_ac790be9d7fbcbf9f765ebdd90f761c71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PackMapping.html">PackMapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac790be9d7fbcbf9f765ebdd90f761c71">packOptimally</a> (bool preserveAABBTree=true)</td></tr>
<tr class="separator:ac790be9d7fbcbf9f765ebdd90f761c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6e569587fbe83e40119a29f7ea276f" id="r_abd6e569587fbe83e40119a29f7ea276f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; <a class="el" href="structMR_1_1PackMapping.html">PackMapping</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd6e569587fbe83e40119a29f7ea276f">packOptimally</a> (bool preserveAABBTree, <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> cb)</td></tr>
<tr class="separator:abd6e569587fbe83e40119a29f7ea276f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bb3faf52ec585da5606ce879ab3c4b" id="r_a21bb3faf52ec585da5606ce879ab3c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21bb3faf52ec585da5606ce879ab3c4b">deleteFaces</a> (const FaceBitSet &amp;fs, const UndirectedEdgeBitSet *keepEdges=nullptr)</td></tr>
<tr class="memdesc:a21bb3faf52ec585da5606ce879ab3c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes multiple given faces, also deletes adjacent edges and vertices if they were not shared by remaining faces ant not in  <br /></td></tr>
<tr class="separator:a21bb3faf52ec585da5606ce879ab3c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726a27c8dbdef71902d1031424bea5cf" id="r_a726a27c8dbdef71902d1031424bea5cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a726a27c8dbdef71902d1031424bea5cf">projectPoint</a> (const Vector3f &amp;point, <a class="el" href="structMR_1_1PointOnFace.html">PointOnFace</a> &amp;res, float maxDistSq=FLT_MAX, const FaceBitSet *region=nullptr, const AffineXf3f *xf=nullptr) const</td></tr>
<tr class="separator:a726a27c8dbdef71902d1031424bea5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973baf90b80dc2696bc083577727d4fc" id="r_a973baf90b80dc2696bc083577727d4fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a973baf90b80dc2696bc083577727d4fc">projectPoint</a> (const Vector3f &amp;point, <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;res, float maxDistSq=FLT_MAX, const FaceBitSet *region=nullptr, const AffineXf3f *xf=nullptr) const</td></tr>
<tr class="separator:a973baf90b80dc2696bc083577727d4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b35787713d43cba7a9e486296170bd1" id="r_a6b35787713d43cba7a9e486296170bd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b35787713d43cba7a9e486296170bd1">findClosestPoint</a> (const Vector3f &amp;point, <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;res, float maxDistSq=FLT_MAX, const FaceBitSet *region=nullptr, const AffineXf3f *xf=nullptr) const</td></tr>
<tr class="separator:a6b35787713d43cba7a9e486296170bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a481d355dcb64efa6d98bf8cf8fac6e" id="r_a1a481d355dcb64efa6d98bf8cf8fac6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a481d355dcb64efa6d98bf8cf8fac6e">projectPoint</a> (const Vector3f &amp;point, float maxDistSq=FLT_MAX, const FaceBitSet *region=nullptr, const AffineXf3f *xf=nullptr) const</td></tr>
<tr class="separator:a1a481d355dcb64efa6d98bf8cf8fac6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f5c45d387fbc95682d09935fb2893d" id="r_a87f5c45d387fbc95682d09935fb2893d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87f5c45d387fbc95682d09935fb2893d">findClosestPoint</a> (const Vector3f &amp;point, float maxDistSq=FLT_MAX, const FaceBitSet *region=nullptr, const AffineXf3f *xf=nullptr) const</td></tr>
<tr class="separator:a87f5c45d387fbc95682d09935fb2893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1684c253364cffbe817aebd50bdf711f" id="r_a1684c253364cffbe817aebd50bdf711f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> const <a class="el" href="classMR_1_1AABBTree.html">AABBTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1684c253364cffbe817aebd50bdf711f">getAABBTree</a> () const</td></tr>
<tr class="memdesc:a1684c253364cffbe817aebd50bdf711f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns cached aabb-tree for this mesh, creating it if it did not exist in a thread-safe manner  <br /></td></tr>
<tr class="separator:a1684c253364cffbe817aebd50bdf711f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4be0475ee77042c23f150bf522aae7" id="r_a3a4be0475ee77042c23f150bf522aae7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMR_1_1AABBTree.html">AABBTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a4be0475ee77042c23f150bf522aae7">getAABBTreeNotCreate</a> () const</td></tr>
<tr class="memdesc:a3a4be0475ee77042c23f150bf522aae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns cached aabb-tree for this mesh, but does not create it if it did not exist  <br /></td></tr>
<tr class="separator:a3a4be0475ee77042c23f150bf522aae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace32bbac5b626dbbf99b27214ebed57d" id="r_ace32bbac5b626dbbf99b27214ebed57d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace32bbac5b626dbbf99b27214ebed57d">getAABBTreePoints</a> () const</td></tr>
<tr class="memdesc:ace32bbac5b626dbbf99b27214ebed57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns cached aabb-tree for points of this mesh, creating it if it did not exist in a thread-safe manner  <br /></td></tr>
<tr class="separator:ace32bbac5b626dbbf99b27214ebed57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f3660852b3da7957b674e29f125150" id="r_a88f3660852b3da7957b674e29f125150"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88f3660852b3da7957b674e29f125150">getAABBTreePointsNotCreate</a> () const</td></tr>
<tr class="memdesc:a88f3660852b3da7957b674e29f125150"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns cached aabb-tree for points of this mesh, but does not create it if it did not exist  <br /></td></tr>
<tr class="separator:a88f3660852b3da7957b674e29f125150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43237a5df3be3b980a3147ceb8710a22" id="r_a43237a5df3be3b980a3147ceb8710a22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> const Dipoles &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43237a5df3be3b980a3147ceb8710a22">getDipoles</a> () const</td></tr>
<tr class="memdesc:a43237a5df3be3b980a3147ceb8710a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns cached dipoles of aabb-tree nodes for this mesh, creating it if it did not exist in a thread-safe manner  <br /></td></tr>
<tr class="separator:a43237a5df3be3b980a3147ceb8710a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa011de9d0180060e3b1dbcc27917c54b" id="r_aa011de9d0180060e3b1dbcc27917c54b"><td class="memItemLeft" align="right" valign="top">const Dipoles *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa011de9d0180060e3b1dbcc27917c54b">getDipolesNotCreate</a> () const</td></tr>
<tr class="memdesc:aa011de9d0180060e3b1dbcc27917c54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns cached dipoles of aabb-tree nodes for this mesh, but does not create it if it did not exist  <br /></td></tr>
<tr class="separator:aa011de9d0180060e3b1dbcc27917c54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cfa4d1a1f01bbcf883f4e96079e505" id="r_ac4cfa4d1a1f01bbcf883f4e96079e505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4cfa4d1a1f01bbcf883f4e96079e505">invalidateCaches</a> (bool pointsChanged=true)</td></tr>
<tr class="separator:ac4cfa4d1a1f01bbcf883f4e96079e505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64499dab83be6cf5433119a613d6953" id="r_ad64499dab83be6cf5433119a613d6953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad64499dab83be6cf5433119a613d6953">updateCaches</a> (const VertBitSet &amp;changedVerts)</td></tr>
<tr class="separator:ad64499dab83be6cf5433119a613d6953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1942a02f00e2404cfbf897d88f3f732" id="r_ac1942a02f00e2404cfbf897d88f3f732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1942a02f00e2404cfbf897d88f3f732">heapBytes</a> () const</td></tr>
<tr class="separator:ac1942a02f00e2404cfbf897d88f3f732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12917935a6261c2bbffbcc979a91abde" id="r_a12917935a6261c2bbffbcc979a91abde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12917935a6261c2bbffbcc979a91abde">shrinkToFit</a> ()</td></tr>
<tr class="memdesc:a12917935a6261c2bbffbcc979a91abde"><td class="mdescLeft">&#160;</td><td class="mdescRight">requests the removal of unused capacity  <br /></td></tr>
<tr class="separator:a12917935a6261c2bbffbcc979a91abde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9148479b241d5fe774cd7bc6dd5ce142" id="r_a9148479b241d5fe774cd7bc6dd5ce142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9148479b241d5fe774cd7bc6dd5ce142">mirror</a> (const Plane3f &amp;plane)</td></tr>
<tr class="memdesc:a9148479b241d5fe774cd7bc6dd5ce142"><td class="mdescLeft">&#160;</td><td class="mdescRight">reflects the mesh from a given plane  <br /></td></tr>
<tr class="separator:a9148479b241d5fe774cd7bc6dd5ce142"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4512a13225dccd2691ad4106c46e3d7a" id="r_a4512a13225dccd2691ad4106c46e3d7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4512a13225dccd2691ad4106c46e3d7a">fromTriangles</a> (VertCoords vertexCoordinates, const Triangulation &amp;t, const <a class="el" href="structMR_1_1MeshBuilder_1_1BuildSettings.html">MeshBuilder::BuildSettings</a> &amp;settings={}, <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> cb={})</td></tr>
<tr class="memdesc:a4512a13225dccd2691ad4106c46e3d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct mesh from vertex coordinates and a set of triangles with given ids  <br /></td></tr>
<tr class="separator:a4512a13225dccd2691ad4106c46e3d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac504344423bcd4292f8d75e4c7ee6d6d" id="r_ac504344423bcd4292f8d75e4c7ee6d6d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac504344423bcd4292f8d75e4c7ee6d6d">fromTriMesh</a> (<a class="el" href="structMR_1_1TriMesh.html">TriMesh</a> &amp;&amp;triMesh, const <a class="el" href="structMR_1_1MeshBuilder_1_1BuildSettings.html">MeshBuilder::BuildSettings</a> &amp;settings={}, <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> cb={})</td></tr>
<tr class="memdesc:ac504344423bcd4292f8d75e4c7ee6d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct mesh from <a class="el" href="structMR_1_1TriMesh.html">TriMesh</a> representation  <br /></td></tr>
<tr class="separator:ac504344423bcd4292f8d75e4c7ee6d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3189b1e26154d13fa969a44545916c" id="r_a5c3189b1e26154d13fa969a44545916c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c3189b1e26154d13fa969a44545916c">fromTrianglesDuplicatingNonManifoldVertices</a> (VertCoords vertexCoordinates, Triangulation &amp;t, std::vector&lt; <a class="el" href="structMR_1_1MeshBuilder_1_1VertDuplication.html">MeshBuilder::VertDuplication</a> &gt; *dups=nullptr, const <a class="el" href="structMR_1_1MeshBuilder_1_1BuildSettings.html">MeshBuilder::BuildSettings</a> &amp;settings={})</td></tr>
<tr class="separator:a5c3189b1e26154d13fa969a44545916c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ac9e60296e45307e29b01f339aaf5f" id="r_ac8ac9e60296e45307e29b01f339aaf5f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8ac9e60296e45307e29b01f339aaf5f">fromFaceSoup</a> (VertCoords vertexCoordinates, const std::vector&lt; VertId &gt; &amp;verts, const <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt; <a class="el" href="structMR_1_1MeshBuilder_1_1VertSpan.html">MeshBuilder::VertSpan</a>, FaceId &gt; &amp;faces, const <a class="el" href="structMR_1_1MeshBuilder_1_1BuildSettings.html">MeshBuilder::BuildSettings</a> &amp;settings={}, <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> cb={})</td></tr>
<tr class="separator:ac8ac9e60296e45307e29b01f339aaf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5500ddb4660086a3703345d50241d0ad" id="r_a5500ddb4660086a3703345d50241d0ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5500ddb4660086a3703345d50241d0ad">fromPointTriples</a> (const std::vector&lt; <a class="el" href="namespaceMR.html#ac3b4f93ff16dbb5975ce8dec6adc39cf">Triangle3f</a> &gt; &amp;posTriples, bool duplicateNonManifoldVertices)</td></tr>
<tr class="separator:a5500ddb4660086a3703345d50241d0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a91b13898794821d7f88845ebaa6cc1c4" id="r_a91b13898794821d7f88845ebaa6cc1c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91b13898794821d7f88845ebaa6cc1c4">topology</a></td></tr>
<tr class="separator:a91b13898794821d7f88845ebaa6cc1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8ead50efe2f8a111848b488f0a6aca" id="r_a9c8ead50efe2f8a111848b488f0a6aca"><td class="memItemLeft" align="right" valign="top">VertCoords&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c8ead50efe2f8a111848b488f0a6aca">points</a></td></tr>
<tr class="separator:a9c8ead50efe2f8a111848b488f0a6aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a mesh, including topology (connectivity) information and point coordinates, as well as some caches to accelerate search algorithms </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8ceec437a01ce063998c0f63f339f246" name="a8ceec437a01ce063998c0f63f339f246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ceec437a01ce063998c0f63f339f246">&#9670;&#160;</a></span>addPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::addPart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceMap *</td>          <td class="paramname"><span class="paramname"><em>outFmap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertMap *</td>          <td class="paramname"><span class="paramname"><em>outVmap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WholeEdgeMap *</td>          <td class="paramname"><span class="paramname"><em>outEmap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>rearrangeTriangles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>appends mesh (from) in addition to this mesh: creates new edges, faces, verts and points </p>

</div>
</div>
<a id="a3a79f0f44fbbd679cff801144ef2df62" name="a3a79f0f44fbbd679cff801144ef2df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a79f0f44fbbd679cff801144ef2df62">&#9670;&#160;</a></span>addPartBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceMR.html#aae89e209e34f26d7ae6dcc7b5e7d2851">I</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::addPartBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#aae89e209e34f26d7ae6dcc7b5e7d2851">I</a></td>          <td class="paramname"><span class="paramname"><em>fbegin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#aae89e209e34f26d7ae6dcc7b5e7d2851">I</a></td>          <td class="paramname"><span class="paramname"><em>fend</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>fcount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flipOrientation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>thisContours</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fromContours</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMR_1_1PartMapping.html">PartMapping</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>both addPartByMask and addPartByFaceMap call this general implementation </p>

</div>
</div>
<a id="abfa14b4d2f6105806b0de757c0a87b7c" name="abfa14b4d2f6105806b0de757c0a87b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa14b4d2f6105806b0de757c0a87b7c">&#9670;&#160;</a></span>addPartByFaceMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::addPartByFaceMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceMap &amp;</td>          <td class="paramname"><span class="paramname"><em>fromFaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flipOrientation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>thisContours</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fromContours</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PartMapping.html">PartMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fromFaces contains mapping from this-mesh (considering it is empty) to from-mesh </p>

</div>
</div>
<a id="a5686eed5d8d32c71c450f51644695a09" name="a5686eed5d8d32c71c450f51644695a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5686eed5d8d32c71c450f51644695a09">&#9670;&#160;</a></span>addPartByMask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::addPartByMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet &amp;</td>          <td class="paramname"><span class="paramname"><em>fromFaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flipOrientation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>thisContours</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fromContours</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PartMapping.html">PartMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this version has more parameters: if flipOrientation then every from triangle is inverted before adding </p>

</div>
</div>
<a id="ae5fb0761925dbb24dbb414e74fd881bc" name="ae5fb0761925dbb24dbb414e74fd881bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fb0761925dbb24dbb414e74fd881bc">&#9670;&#160;</a></span>addPartByMask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::addPartByMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet &amp;</td>          <td class="paramname"><span class="paramname"><em>fromFaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PartMapping.html">PartMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the same but copies only portion of (from) specified by fromFaces </p>

</div>
</div>
<a id="aee64892c6401f2ffc0394a59628cdbb5" name="aee64892c6401f2ffc0394a59628cdbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee64892c6401f2ffc0394a59628cdbb5">&#9670;&#160;</a></span>addPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId MR::Mesh::addPoint </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates new point and assigns given position to it </p>

</div>
</div>
<a id="abd8119f3200435e62435f6ec375d98c1" name="abd8119f3200435e62435f6ec375d98c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8119f3200435e62435f6ec375d98c1">&#9670;&#160;</a></span>addSeparateContours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId MR::Mesh::addSeparateContours </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#ac93791b17f5bb1ff4a6a7e7f51a7abc9">Contours3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>contours</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>append points to mesh and connect them returns first EdgeId of new edges </p>

</div>
</div>
<a id="afe79fbba41c13a31bd40b10fdff8b5ee" name="afe79fbba41c13a31bd40b10fdff8b5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe79fbba41c13a31bd40b10fdff8b5ee">&#9670;&#160;</a></span>addSeparateEdgeLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId MR::Mesh::addSeparateEdgeLoop </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Vector3f &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>contourPoints</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>append points to mesh and connect them as closed edge loop returns first EdgeId of new edges </p>

</div>
</div>
<a id="a0c83a5a324f80a18969d786febaee653" name="a0c83a5a324f80a18969d786febaee653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c83a5a324f80a18969d786febaee653">&#9670;&#160;</a></span>area() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> double MR::Mesh::area </td>
          <td>(</td>
          <td class="paramtype">const FaceBitSet &amp;</td>          <td class="paramname"><span class="paramname"><em>fs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the area of given face-region </p>

</div>
</div>
<a id="a45cc8a4868a2671492e010d86cb408cd" name="a45cc8a4868a2671492e010d86cb408cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cc8a4868a2671492e010d86cb408cd">&#9670;&#160;</a></span>area() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MR::Mesh::area </td>
          <td>(</td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>fs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the area of given face-region (or whole mesh) </p>

</div>
</div>
<a id="a03632276528ce953490a2111a5280c7c" name="a03632276528ce953490a2111a5280c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03632276528ce953490a2111a5280c7c">&#9670;&#160;</a></span>area() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MR::Mesh::area </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the area of given face </p>

</div>
</div>
<a id="abab2d759266b7e751ef91845d21afd98" name="abab2d759266b7e751ef91845d21afd98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab2d759266b7e751ef91845d21afd98">&#9670;&#160;</a></span>attachEdgeLoopPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::attachEdgeLoopPart </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector3f &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>contourPoints</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>append points to mesh and connect them to given edges making edge loop first point connects with first edge dest last point connects with last edge org note that first and last edge should have no left face </p>

</div>
</div>
<a id="ace0fa1663015706fa78dc52fe840b4a9" name="ace0fa1663015706fa78dc52fe840b4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0fa1663015706fa78dc52fe840b4a9">&#9670;&#160;</a></span>averageEdgeLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::averageEdgeLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes average length of an edge in this mesh </p>

</div>
</div>
<a id="a0ddf4af17627f59df39990e32ea87c04" name="a0ddf4af17627f59df39990e32ea87c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddf4af17627f59df39990e32ea87c04">&#9670;&#160;</a></span>calcFastWindingNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::calcFastWindingNumber </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>beta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes generalized winding number in a point (pt), which is</p><ul>
<li>for closed mesh with normals outside: 1 inside, 0 outside;</li>
<li>for planar mesh: 0.5 inside, -0.5 outside; and in general is equal to (portion of solid angle where inside part of mesh is observable) minus (portion of solid angle where outside part of mesh is observable) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>determines the precision of fast approximation: the more the better, recommended value 2 or more </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a9c995113408ff1e1911197ea23564987" name="a9c995113408ff1e1911197ea23564987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c995113408ff1e1911197ea23564987">&#9670;&#160;</a></span>circumcircleDiameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::circumcircleDiameter </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns circumcircle diameter of given mesh triangle </p>

</div>
</div>
<a id="a739c01f192fc474add3f5341ade42018" name="a739c01f192fc474add3f5341ade42018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739c01f192fc474add3f5341ade42018">&#9670;&#160;</a></span>circumcircleDiameterSq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::circumcircleDiameterSq </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns squared circumcircle diameter of given mesh triangle </p>

</div>
</div>
<a id="a2e9331e1cd987b8dab1bceac8a73c5f5" name="a2e9331e1cd987b8dab1bceac8a73c5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9331e1cd987b8dab1bceac8a73c5f5">&#9670;&#160;</a></span>cloneRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a> MR::Mesh::cloneRegion </td>
          <td>(</td>
          <td class="paramtype">const FaceBitSet &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flipOrientation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PartMapping.html">PartMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates new mesh from given triangles of this mesh </p>

</div>
</div>
<a id="a30783b277e8cd9daed4827c15daede28" name="a30783b277e8cd9daed4827c15daede28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30783b277e8cd9daed4827c15daede28">&#9670;&#160;</a></span>computeBoundingBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Box3f MR::Mesh::computeBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>toWorld</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>passes through all valid vertices and finds the minimal bounding box containing all of them; if toWorld transformation is given then returns minimal bounding box in world space </p>

</div>
</div>
<a id="a091677e4ef6993ac15490326ebcc1c78" name="a091677e4ef6993ac15490326ebcc1c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091677e4ef6993ac15490326ebcc1c78">&#9670;&#160;</a></span>computeBoundingBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Box3f MR::Mesh::computeBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>toWorld</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>passes through all given faces (or whole mesh if region == null) and finds the minimal bounding box containing all of them if toWorld transformation is given then returns minimal bounding box in world space </p>

</div>
</div>
<a id="aae3794627367f1c0ae6a497f41542197" name="aae3794627367f1c0ae6a497f41542197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3794627367f1c0ae6a497f41542197">&#9670;&#160;</a></span>cotan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MR::Mesh::cotan </td>
          <td>(</td>
          <td class="paramtype">UndirectedEdgeId</td>          <td class="paramname"><span class="paramname"><em>ue</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes sum of cotangents of the angle in the left and right triangles opposite to given edge, and returns 0 if left face does not exist </p>

</div>
</div>
<a id="a1e2a8eaf7d1882e02a3eea66d1d72349" name="a1e2a8eaf7d1882e02a3eea66d1d72349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2a8eaf7d1882e02a3eea66d1d72349">&#9670;&#160;</a></span>dblArea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MR::Mesh::dblArea </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns twice the area of given face </p>

</div>
</div>
<a id="ab6d39814aa495e12ba8e388c22a6f12e" name="ab6d39814aa495e12ba8e388c22a6f12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d39814aa495e12ba8e388c22a6f12e">&#9670;&#160;</a></span>dblArea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MR::Mesh::dblArea </td>
          <td>(</td>
          <td class="paramtype">VertId</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the length of summed directed double areas of all triangles around given vertex </p>

</div>
</div>
<a id="a21bb3faf52ec585da5606ce879ab3c4b" name="a21bb3faf52ec585da5606ce879ab3c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bb3faf52ec585da5606ce879ab3c4b">&#9670;&#160;</a></span>deleteFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::deleteFaces </td>
          <td>(</td>
          <td class="paramtype">const FaceBitSet &amp;</td>          <td class="paramname"><span class="paramname"><em>fs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UndirectedEdgeBitSet *</td>          <td class="paramname"><span class="paramname"><em>keepEdges</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deletes multiple given faces, also deletes adjacent edges and vertices if they were not shared by remaining faces ant not in </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepFaces</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6241859f835aa7cd22f26c1e40b9791a" name="a6241859f835aa7cd22f26c1e40b9791a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6241859f835aa7cd22f26c1e40b9791a">&#9670;&#160;</a></span>destPnt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3f MR::Mesh::destPnt </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns coordinates of the edge destination </p>

</div>
</div>
<a id="a938d6bd536f16b6f46394ceb91271053" name="a938d6bd536f16b6f46394ceb91271053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938d6bd536f16b6f46394ceb91271053">&#9670;&#160;</a></span>dihedralAngle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::dihedralAngle </td>
          <td>(</td>
          <td class="paramtype">UndirectedEdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>given an edge between two triangular faces, computes the dihedral angle between them: 0 if both faces are in the same plane, positive if the faces form convex surface, negative if the faces form concave surface; please consider the usage of faster dihedralAngleSin(e) and dihedralAngleCos(e) </p>

</div>
</div>
<a id="afbc9fe4f12054a0171667825056fe457" name="afbc9fe4f12054a0171667825056fe457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc9fe4f12054a0171667825056fe457">&#9670;&#160;</a></span>dihedralAngleCos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::dihedralAngleCos </td>
          <td>(</td>
          <td class="paramtype">UndirectedEdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>given an edge between two triangular faces, computes cosine of dihedral angle between them: 1 if both faces are in the same plane, 0 if the surface makes right angle turn at the edge, -1 if the faces overlap one another </p>

</div>
</div>
<a id="a08a599e9255943ae4fab5935502d2f21" name="a08a599e9255943ae4fab5935502d2f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a599e9255943ae4fab5935502d2f21">&#9670;&#160;</a></span>dihedralAngleSin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::dihedralAngleSin </td>
          <td>(</td>
          <td class="paramtype">UndirectedEdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>given an edge between two triangular faces, computes sine of dihedral angle between them: 0 if both faces are in the same plane, positive if the faces form convex surface, negative if the faces form concave surface </p>

</div>
</div>
<a id="a1d2049ae64855f1b9d7c6da0d946faa3" name="a1d2049ae64855f1b9d7c6da0d946faa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2049ae64855f1b9d7c6da0d946faa3">&#9670;&#160;</a></span>dirArea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3d MR::Mesh::dirArea </td>
          <td>(</td>
          <td class="paramtype">const FaceBitSet &amp;</td>          <td class="paramname"><span class="paramname"><em>fs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the sum of directed areas for faces from given region </p>

</div>
</div>
<a id="a029d8d453e90f13a14ae22b25a71db47" name="a029d8d453e90f13a14ae22b25a71db47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029d8d453e90f13a14ae22b25a71db47">&#9670;&#160;</a></span>dirArea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d MR::Mesh::dirArea </td>
          <td>(</td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>fs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the sum of directed areas for faces from given region (or whole mesh) </p>

</div>
</div>
<a id="afd3563494ce9b9a0cf5a7e4346606961" name="afd3563494ce9b9a0cf5a7e4346606961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3563494ce9b9a0cf5a7e4346606961">&#9670;&#160;</a></span>dirDblArea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3f MR::Mesh::dirDblArea </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes directed double area for a triangular face from its vertices </p>

</div>
</div>
<a id="a4237bb2ee8edbc72aa4189bc2307a544" name="a4237bb2ee8edbc72aa4189bc2307a544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4237bb2ee8edbc72aa4189bc2307a544">&#9670;&#160;</a></span>dirDblArea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f MR::Mesh::dirDblArea </td>
          <td>(</td>
          <td class="paramtype">VertId</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes sum of directed double areas of all triangles around given vertex </p>

</div>
</div>
<a id="a18e24b802c039dde02eeb902045cdb20" name="a18e24b802c039dde02eeb902045cdb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e24b802c039dde02eeb902045cdb20">&#9670;&#160;</a></span>discreteGaussianCurvature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MR::Mesh::discreteGaussianCurvature </td>
          <td>(</td>
          <td class="paramtype">VertId</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>outBoundaryVert</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes discrete Gaussian curvature (or angle defect) at given vertex, which 0 in inner vertices on planar mesh parts and reaches 2*pi on needle's tip, see <a href="http://math.uchicago.edu/~may/REU2015/REUPapers/Upadhyay.pdf">http://math.uchicago.edu/~may/REU2015/REUPapers/Upadhyay.pdf</a> optionally returns whether the vertex is on boundary </p>

</div>
</div>
<a id="ad85462881d0758cd78deba62d9bbc416" name="ad85462881d0758cd78deba62d9bbc416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85462881d0758cd78deba62d9bbc416">&#9670;&#160;</a></span>discreteMeanCurvature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::discreteMeanCurvature </td>
          <td>(</td>
          <td class="paramtype">UndirectedEdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes discrete mean curvature in given edge, measures in length^-1; 0 for planar regions, positive for convex surface, negative for concave surface </p>

</div>
</div>
<a id="ab555df576a4de372990fabcac596979f" name="ab555df576a4de372990fabcac596979f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab555df576a4de372990fabcac596979f">&#9670;&#160;</a></span>discreteMeanCurvature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::discreteMeanCurvature </td>
          <td>(</td>
          <td class="paramtype">VertId</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes discrete mean curvature in given vertex, measures in length^-1; 0 for planar regions, positive for convex surface, negative for concave surface </p>

</div>
</div>
<a id="ad45947ba454ab92f4c8bacbcd94b17f4" name="ad45947ba454ab92f4c8bacbcd94b17f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45947ba454ab92f4c8bacbcd94b17f4">&#9670;&#160;</a></span>edgeCenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3f MR::Mesh::edgeCenter </td>
          <td>(</td>
          <td class="paramtype">UndirectedEdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the center of given edge </p>

</div>
</div>
<a id="ad741164ba566adeb2830a4de3861bfd0" name="ad741164ba566adeb2830a4de3861bfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad741164ba566adeb2830a4de3861bfd0">&#9670;&#160;</a></span>edgeLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MR::Mesh::edgeLength </td>
          <td>(</td>
          <td class="paramtype">UndirectedEdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns Euclidean length of the edge </p>

</div>
</div>
<a id="a4dda7695db1d721bc3cb64bb374c89c4" name="a4dda7695db1d721bc3cb64bb374c89c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dda7695db1d721bc3cb64bb374c89c4">&#9670;&#160;</a></span>edgeLengthSq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MR::Mesh::edgeLengthSq </td>
          <td>(</td>
          <td class="paramtype">UndirectedEdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns squared Euclidean length of the edge (faster to compute than length) </p>

</div>
</div>
<a id="abdbd41edd56e7e2c65589e9d7b0687fa" name="abdbd41edd56e7e2c65589e9d7b0687fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbd41edd56e7e2c65589e9d7b0687fa">&#9670;&#160;</a></span>edgePoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3f MR::Mesh::edgePoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMR.html#a8ffb37085bbd6060f17bcf222941ab8c">MeshEdgePoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ep</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes coordinates of point given as edge and relative position on it </p>

</div>
</div>
<a id="a584a6ede1ccbc7e9568e03eb8abd4ed5" name="a584a6ede1ccbc7e9568e03eb8abd4ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584a6ede1ccbc7e9568e03eb8abd4ed5">&#9670;&#160;</a></span>edgePoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3f MR::Mesh::edgePoint </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a point on the edge: origin point for f=0 and destination point for f=1 </p>

</div>
</div>
<a id="a840bac6e56b6be19515df2d1a3cf69fd" name="a840bac6e56b6be19515df2d1a3cf69fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840bac6e56b6be19515df2d1a3cf69fd">&#9670;&#160;</a></span>edgeSegment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LineSegm3f MR::Mesh::edgeSegment </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns line segment of given edge </p>

</div>
</div>
<a id="a19223c76e1742c8cf6a56fd51b5c2c68" name="a19223c76e1742c8cf6a56fd51b5c2c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19223c76e1742c8cf6a56fd51b5c2c68">&#9670;&#160;</a></span>edgeVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3f MR::Mesh::edgeVector </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns vector equal to edge destination point minus edge origin point </p>

</div>
</div>
<a id="a7ef2784fa43035776fad3e85ac252642" name="a7ef2784fa43035776fad3e85ac252642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef2784fa43035776fad3e85ac252642">&#9670;&#160;</a></span>findCenterFromBBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f MR::Mesh::findCenterFromBBox </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes bounding box and returns its center </p>

</div>
</div>
<a id="a1576164a9505c9f8c28e16dc288bcca9" name="a1576164a9505c9f8c28e16dc288bcca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1576164a9505c9f8c28e16dc288bcca9">&#9670;&#160;</a></span>findCenterFromFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f MR::Mesh::findCenterFromFaces </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes center of mass considering that density of all triangles is the same </p>

</div>
</div>
<a id="a4cf526a36b567b3e072c3aa70d628ee2" name="a4cf526a36b567b3e072c3aa70d628ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf526a36b567b3e072c3aa70d628ee2">&#9670;&#160;</a></span>findCenterFromPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f MR::Mesh::findCenterFromPoints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes average position of all valid mesh vertices </p>

</div>
</div>
<a id="a87f5c45d387fbc95682d09935fb2893d" name="a87f5c45d387fbc95682d09935fb2893d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f5c45d387fbc95682d09935fb2893d">&#9670;&#160;</a></span>findClosestPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &gt; MR::Mesh::findClosestPoint </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maxDistSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b35787713d43cba7a9e486296170bd1" name="a6b35787713d43cba7a9e486296170bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b35787713d43cba7a9e486296170bd1">&#9670;&#160;</a></span>findClosestPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MR::Mesh::findClosestPoint </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maxDistSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3597555fee6f4964fe1689b0643f7f83" name="a3597555fee6f4964fe1689b0643f7f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3597555fee6f4964fe1689b0643f7f83">&#9670;&#160;</a></span>findCreaseEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> UndirectedEdgeBitSet MR::Mesh::findCreaseEdges </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>angleFromPlanar</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds all mesh edges where dihedral angle is distinct from planar PI angle on at least given value </p>

</div>
</div>
<a id="a63974f1e9e91aec82c60fc776f51ea7b" name="a63974f1e9e91aec82c60fc776f51ea7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63974f1e9e91aec82c60fc776f51ea7b">&#9670;&#160;</a></span>findSpikeVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; VertBitSet &gt; MR::Mesh::findSpikeVertices </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>minSumAngle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a></td>          <td class="paramname"><span class="paramname"><em>cb</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns vertices where the sum of triangle angles is below given threshold </p>

</div>
</div>
<a id="ac8ac9e60296e45307e29b01f339aaf5f" name="ac8ac9e60296e45307e29b01f339aaf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ac9e60296e45307e29b01f339aaf5f">&#9670;&#160;</a></span>fromFaceSoup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a> MR::Mesh::fromFaceSoup </td>
          <td>(</td>
          <td class="paramtype">VertCoords</td>          <td class="paramname"><span class="paramname"><em>vertexCoordinates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; VertId &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>verts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt; <a class="el" href="structMR_1_1MeshBuilder_1_1VertSpan.html">MeshBuilder::VertSpan</a>, FaceId &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>faces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshBuilder_1_1BuildSettings.html">MeshBuilder::BuildSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a></td>          <td class="paramname"><span class="paramname"><em>cb</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>construct mesh from vertex coordinates and construct mesh topology from face soup, where each face can have arbitrary degree (not only triangles); all non-triangular faces will be automatically subdivided on triangles </p>

</div>
</div>
<a id="a5500ddb4660086a3703345d50241d0ad" name="a5500ddb4660086a3703345d50241d0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5500ddb4660086a3703345d50241d0ad">&#9670;&#160;</a></span>fromPointTriples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a> MR::Mesh::fromPointTriples </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceMR.html#ac3b4f93ff16dbb5975ce8dec6adc39cf">Triangle3f</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>posTriples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>duplicateNonManifoldVertices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>construct mesh from point triples; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duplicateNonManifoldVertices</td><td>= false, all coinciding points are given the same VertId in the result; </td></tr>
    <tr><td class="paramname">duplicateNonManifoldVertices</td><td>= true, it tries to avoid non-manifold vertices by creating duplicate vertices with same coordinates <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4512a13225dccd2691ad4106c46e3d7a" name="a4512a13225dccd2691ad4106c46e3d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4512a13225dccd2691ad4106c46e3d7a">&#9670;&#160;</a></span>fromTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a> MR::Mesh::fromTriangles </td>
          <td>(</td>
          <td class="paramtype">VertCoords</td>          <td class="paramname"><span class="paramname"><em>vertexCoordinates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Triangulation &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshBuilder_1_1BuildSettings.html">MeshBuilder::BuildSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a></td>          <td class="paramname"><span class="paramname"><em>cb</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct mesh from vertex coordinates and a set of triangles with given ids </p>

</div>
</div>
<a id="a5c3189b1e26154d13fa969a44545916c" name="a5c3189b1e26154d13fa969a44545916c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3189b1e26154d13fa969a44545916c">&#9670;&#160;</a></span>fromTrianglesDuplicatingNonManifoldVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a> MR::Mesh::fromTrianglesDuplicatingNonManifoldVertices </td>
          <td>(</td>
          <td class="paramtype">VertCoords</td>          <td class="paramname"><span class="paramname"><em>vertexCoordinates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Triangulation &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structMR_1_1MeshBuilder_1_1VertDuplication.html">MeshBuilder::VertDuplication</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dups</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshBuilder_1_1BuildSettings.html">MeshBuilder::BuildSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>construct mesh from vertex coordinates and a set of triangles with given ids; unlike simple <a class="el" href="#a4512a13225dccd2691ad4106c46e3d7a" title="construct mesh from vertex coordinates and a set of triangles with given ids">fromTriangles()</a> it tries to resolve non-manifold vertices by creating duplicate vertices </p>

</div>
</div>
<a id="ac504344423bcd4292f8d75e4c7ee6d6d" name="ac504344423bcd4292f8d75e4c7ee6d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac504344423bcd4292f8d75e4c7ee6d6d">&#9670;&#160;</a></span>fromTriMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1Mesh.html">Mesh</a> MR::Mesh::fromTriMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMR_1_1TriMesh.html">TriMesh</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>triMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshBuilder_1_1BuildSettings.html">MeshBuilder::BuildSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a></td>          <td class="paramname"><span class="paramname"><em>cb</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct mesh from <a class="el" href="structMR_1_1TriMesh.html">TriMesh</a> representation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triMesh</td><td>points of triMesh will be moves in the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1684c253364cffbe817aebd50bdf711f" name="a1684c253364cffbe817aebd50bdf711f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1684c253364cffbe817aebd50bdf711f">&#9670;&#160;</a></span>getAABBTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> const <a class="el" href="classMR_1_1AABBTree.html">AABBTree</a> &amp; MR::Mesh::getAABBTree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns cached aabb-tree for this mesh, creating it if it did not exist in a thread-safe manner </p>

</div>
</div>
<a id="a3a4be0475ee77042c23f150bf522aae7" name="a3a4be0475ee77042c23f150bf522aae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4be0475ee77042c23f150bf522aae7">&#9670;&#160;</a></span>getAABBTreeNotCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMR_1_1AABBTree.html">AABBTree</a> * MR::Mesh::getAABBTreeNotCreate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns cached aabb-tree for this mesh, but does not create it if it did not exist </p>

</div>
</div>
<a id="ace32bbac5b626dbbf99b27214ebed57d" name="ace32bbac5b626dbbf99b27214ebed57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace32bbac5b626dbbf99b27214ebed57d">&#9670;&#160;</a></span>getAABBTreePoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp; MR::Mesh::getAABBTreePoints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns cached aabb-tree for points of this mesh, creating it if it did not exist in a thread-safe manner </p>

</div>
</div>
<a id="a88f3660852b3da7957b674e29f125150" name="a88f3660852b3da7957b674e29f125150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f3660852b3da7957b674e29f125150">&#9670;&#160;</a></span>getAABBTreePointsNotCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> * MR::Mesh::getAABBTreePointsNotCreate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns cached aabb-tree for points of this mesh, but does not create it if it did not exist </p>

</div>
</div>
<a id="a6a9114dc0640fc079b18e83625c3464a" name="a6a9114dc0640fc079b18e83625c3464a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9114dc0640fc079b18e83625c3464a">&#9670;&#160;</a></span>getBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Box3f MR::Mesh::getBoundingBox </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns the bounding box containing all valid vertices (implemented via <a class="el" href="#a1684c253364cffbe817aebd50bdf711f" title="returns cached aabb-tree for this mesh, creating it if it did not exist in a thread-safe manner">getAABBTree()</a>) this bounding box is insignificantly bigger that minimal box due to AABB algorithms precision </p>

</div>
</div>
<a id="a91c234ebc0fba018fda6c46a072d8089" name="a91c234ebc0fba018fda6c46a072d8089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c234ebc0fba018fda6c46a072d8089">&#9670;&#160;</a></span>getClosestEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UndirectedEdgeId MR::Mesh::getClosestEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns one of three face edges, closest to given point </p>

</div>
</div>
<a id="a1b6db3be66aadef6658a7692c9181713" name="a1b6db3be66aadef6658a7692c9181713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6db3be66aadef6658a7692c9181713">&#9670;&#160;</a></span>getClosestEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> UndirectedEdgeId MR::Mesh::getClosestEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointOnFace.html">PointOnFace</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns one of three face edges, closest to given point </p>

</div>
</div>
<a id="a08e825f78e748198301ee280cbb88b9c" name="a08e825f78e748198301ee280cbb88b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e825f78e748198301ee280cbb88b9c">&#9670;&#160;</a></span>getClosestVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VertId MR::Mesh::getClosestVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns one of three face vertices, closest to given point </p>

</div>
</div>
<a id="a4fe5788ff7927b5a1b5f70b157353ab6" name="a4fe5788ff7927b5a1b5f70b157353ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe5788ff7927b5a1b5f70b157353ab6">&#9670;&#160;</a></span>getClosestVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId MR::Mesh::getClosestVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointOnFace.html">PointOnFace</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns one of three face vertices, closest to given point </p>

</div>
</div>
<a id="a43237a5df3be3b980a3147ceb8710a22" name="a43237a5df3be3b980a3147ceb8710a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43237a5df3be3b980a3147ceb8710a22">&#9670;&#160;</a></span>getDipoles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> const Dipoles &amp; MR::Mesh::getDipoles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns cached dipoles of aabb-tree nodes for this mesh, creating it if it did not exist in a thread-safe manner </p>

</div>
</div>
<a id="aa011de9d0180060e3b1dbcc27917c54b" name="aa011de9d0180060e3b1dbcc27917c54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa011de9d0180060e3b1dbcc27917c54b">&#9670;&#160;</a></span>getDipolesNotCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Dipoles * MR::Mesh::getDipolesNotCreate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns cached dipoles of aabb-tree nodes for this mesh, but does not create it if it did not exist </p>

</div>
</div>
<a id="a7173fafd19150c40259003561a02162a" name="a7173fafd19150c40259003561a02162a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7173fafd19150c40259003561a02162a">&#9670;&#160;</a></span>getLeftTriPoints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMR.html#ac3b4f93ff16dbb5975ce8dec6adc39cf">Triangle3f</a> MR::Mesh::getLeftTriPoints </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns three points of left face of e </p>

</div>
</div>
<a id="a7d51b4057ba3a41c5ef11fba53fa8a3c" name="a7d51b4057ba3a41c5ef11fba53fa8a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d51b4057ba3a41c5ef11fba53fa8a3c">&#9670;&#160;</a></span>getLeftTriPoints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::getLeftTriPoints </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>v0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns three points of left face of e </p>

</div>
</div>
<a id="af1c5a975cbd95ff470346d693287bb5d" name="af1c5a975cbd95ff470346d693287bb5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c5a975cbd95ff470346d693287bb5d">&#9670;&#160;</a></span>getLeftTriPoints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MR::Mesh::getLeftTriPoints </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3f(&amp;)</td>          <td class="paramname"><span class="paramname"><em>v</em></span>[3]&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns three points of left face of e </p>

</div>
</div>
<a id="a55a31eccbae1dd87a464a0907aad14ce" name="a55a31eccbae1dd87a464a0907aad14ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a31eccbae1dd87a464a0907aad14ce">&#9670;&#160;</a></span>getTriPoints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMR.html#ac3b4f93ff16dbb5975ce8dec6adc39cf">Triangle3f</a> MR::Mesh::getTriPoints </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns three points of given face </p>

</div>
</div>
<a id="abe211d973521963165b09ad25d9a971c" name="abe211d973521963165b09ad25d9a971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe211d973521963165b09ad25d9a971c">&#9670;&#160;</a></span>getTriPoints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MR::Mesh::getTriPoints </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>v0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns three points of given face </p>

</div>
</div>
<a id="abe28c0649ca99c11e22e99fcce026ffe" name="abe28c0649ca99c11e22e99fcce026ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe28c0649ca99c11e22e99fcce026ffe">&#9670;&#160;</a></span>getTriPoints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MR::Mesh::getTriPoints </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3f(&amp;)</td>          <td class="paramname"><span class="paramname"><em>v</em></span>[3]&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns three points of given face </p>

</div>
</div>
<a id="ac1942a02f00e2404cfbf897d88f3f732" name="ac1942a02f00e2404cfbf897d88f3f732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1942a02f00e2404cfbf897d88f3f732">&#9670;&#160;</a></span>heapBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> size_t MR::Mesh::heapBytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="addb26b3e42dbd2a5418b461add1d9f57" name="addb26b3e42dbd2a5418b461add1d9f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb26b3e42dbd2a5418b461add1d9f57">&#9670;&#160;</a></span>holeDirArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3d MR::Mesh::holeDirArea </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes directed area of the hole specified by one of its edges with no valid left face (left is hole); if the hole is planar then returned vector is orthogonal to the plane pointing outside and its magnitude is equal to hole area </p>

</div>
</div>
<a id="af3fca747ad4dc619010b3f7dbb857f86" name="af3fca747ad4dc619010b3f7dbb857f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fca747ad4dc619010b3f7dbb857f86">&#9670;&#160;</a></span>holePerimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> double MR::Mesh::holePerimiter </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the perimeter of the hole specified by one of its edges with no valid left face (left is hole) </p>

</div>
</div>
<a id="ac4cfa4d1a1f01bbcf883f4e96079e505" name="ac4cfa4d1a1f01bbcf883f4e96079e505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cfa4d1a1f01bbcf883f4e96079e505">&#9670;&#160;</a></span>invalidateCaches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::invalidateCaches </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pointsChanged</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>invalidates caches (aabb-trees) after any change in mesh geometry or topology </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointsChanged</td><td>specifies whether points have changed (otherwise only topology has changed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8121a87b4511118c273836888eb18ab8" name="a8121a87b4511118c273836888eb18ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8121a87b4511118c273836888eb18ab8">&#9670;&#160;</a></span>isOutside()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MR::Mesh::isOutside </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>windingNumberThreshold</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>beta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes whether a point (pt) is located outside the object surrounded by this mesh using generalized winding number </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>determines the precision of winding number computation: the more the better, recommended value 2 or more </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fdc9e5969b065b761018ff5cb0a43a5" name="a0fdc9e5969b065b761018ff5cb0a43a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdc9e5969b065b761018ff5cb0a43a5">&#9670;&#160;</a></span>isOutsideByProjNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::Mesh::isOutsideByProjNorm </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes whether a point (pt) is located outside the object surrounded by this mesh using pseudonormal at the closest point to in on mesh (proj); this method works much faster than <a class="el" href="#a8121a87b4511118c273836888eb18ab8">isOutside</a> but can return wrong sign if the closest point is located on self-intersecting part of the mesh </p>

</div>
</div>
<a id="aa347e7c284659d13d5e9ef0df1a52d5e" name="aa347e7c284659d13d5e9ef0df1a52d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa347e7c284659d13d5e9ef0df1a52d5e">&#9670;&#160;</a></span>leftCotan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::leftCotan </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes cotangent of the angle in the left( e ) triangle opposite to e, and returns 0 if left face does not exist </p>

</div>
</div>
<a id="acfefd886da876ca72f2d96231206ed43" name="acfefd886da876ca72f2d96231206ed43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfefd886da876ca72f2d96231206ed43">&#9670;&#160;</a></span>leftDirDblArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f MR::Mesh::leftDirDblArea </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes directed double area of left triangular face of given edge </p>

</div>
</div>
<a id="a797623a41864029eb93103c262fa70d4" name="a797623a41864029eb93103c262fa70d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797623a41864029eb93103c262fa70d4">&#9670;&#160;</a></span>leftNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3f MR::Mesh::leftNormal </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes triangular face normal from its vertices </p>

</div>
</div>
<a id="a9148479b241d5fe774cd7bc6dd5ce142" name="a9148479b241d5fe774cd7bc6dd5ce142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9148479b241d5fe774cd7bc6dd5ce142">&#9670;&#160;</a></span>mirror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::mirror </td>
          <td>(</td>
          <td class="paramtype">const Plane3f &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reflects the mesh from a given plane </p>

</div>
</div>
<a id="a0bc20c6104570ee76cffee01e1ea9aa0" name="a0bc20c6104570ee76cffee01e1ea9aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc20c6104570ee76cffee01e1ea9aa0">&#9670;&#160;</a></span>normal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f MR::Mesh::normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes normal in three vertices of p's triangle, then interpolates them using barycentric coordinates and normalizes again; this is the same normal as in rendering with smooth shading </p>

</div>
</div>
<a id="acc0ceb8ed258ca42cf125638c6940594" name="acc0ceb8ed258ca42cf125638c6940594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0ceb8ed258ca42cf125638c6940594">&#9670;&#160;</a></span>normal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3f MR::Mesh::normal </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes triangular face normal from its vertices </p>

</div>
</div>
<a id="aff330955f978300560fd33b43cd77cdd" name="aff330955f978300560fd33b43cd77cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff330955f978300560fd33b43cd77cdd">&#9670;&#160;</a></span>normal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3f MR::Mesh::normal </td>
          <td>(</td>
          <td class="paramtype">VertId</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes normal in a vertex using sum of directed areas of neighboring triangles </p>

</div>
</div>
<a id="a994943959e77b3bc34449639c1dfcb6f" name="a994943959e77b3bc34449639c1dfcb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994943959e77b3bc34449639c1dfcb6f">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::Mesh::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare that two meshes are exactly the same </p>

</div>
</div>
<a id="a5fab8c28312fa8c3ac69c2f63d345f20" name="a5fab8c28312fa8c3ac69c2f63d345f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fab8c28312fa8c3ac69c2f63d345f20">&#9670;&#160;</a></span>orgPnt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3f MR::Mesh::orgPnt </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns coordinates of the edge origin </p>

</div>
</div>
<a id="a6d8e2d55d67e606f0129377d0d14aa4a" name="a6d8e2d55d67e606f0129377d0d14aa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8e2d55d67e606f0129377d0d14aa4a">&#9670;&#160;</a></span>pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::pack </td>
          <td>(</td>
          <td class="paramtype">FaceMap *</td>          <td class="paramname"><span class="paramname"><em>outFmap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertMap *</td>          <td class="paramname"><span class="paramname"><em>outVmap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WholeEdgeMap *</td>          <td class="paramname"><span class="paramname"><em>outEmap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>rearrangeTriangles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>tightly packs all arrays eliminating lone edges and invalid face, verts and points, optionally returns mappings: old.id -&gt; new.id </p>

</div>
</div>
<a id="abd6e569587fbe83e40119a29f7ea276f" name="abd6e569587fbe83e40119a29f7ea276f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6e569587fbe83e40119a29f7ea276f">&#9670;&#160;</a></span>packOptimally() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; <a class="el" href="structMR_1_1PackMapping.html">PackMapping</a> &gt; MR::Mesh::packOptimally </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>preserveAABBTree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a></td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac790be9d7fbcbf9f765ebdd90f761c71" name="ac790be9d7fbcbf9f765ebdd90f761c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac790be9d7fbcbf9f765ebdd90f761c71">&#9670;&#160;</a></span>packOptimally() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PackMapping.html">PackMapping</a> MR::Mesh::packOptimally </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>preserveAABBTree</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packs tightly and rearranges vertices, triangles and edges to put close in space elements in close indices </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preserveAABBTree</td><td>whether to keep valid mesh's AABB tree after return (it will take longer to compute and it will occupy more memory) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6410490732e1756a5716df6539c55d45" name="a6410490732e1756a5716df6539c55d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6410490732e1756a5716df6539c55d45">&#9670;&#160;</a></span>projArea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> double MR::Mesh::projArea </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet &amp;</td>          <td class="paramname"><span class="paramname"><em>fs</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the sum of absolute projected area of faces from given region as visible if look from given direction </p>

</div>
</div>
<a id="af4a7cadb50ed558293082e1da4bb24f2" name="af4a7cadb50ed558293082e1da4bb24f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a7cadb50ed558293082e1da4bb24f2">&#9670;&#160;</a></span>projArea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MR::Mesh::projArea </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>fs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the sum of absolute projected area of faces from given region (or whole mesh) as visible if look from given direction </p>

</div>
</div>
<a id="a1a481d355dcb64efa6d98bf8cf8fac6e" name="a1a481d355dcb64efa6d98bf8cf8fac6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a481d355dcb64efa6d98bf8cf8fac6e">&#9670;&#160;</a></span>projectPoint() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &gt; MR::Mesh::projectPoint </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maxDistSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>finds the closest mesh point on this mesh (or its region) to given point; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>source location to look the closest to </td></tr>
    <tr><td class="paramname">maxDistSq</td><td>search only in the ball with sqrt(maxDistSq) radius around given point, smaller value here increases performance </td></tr>
    <tr><td class="paramname">xf</td><td>is mesh-to-point transformation, if not specified then identity transformation is assumed and works much faster; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>found closest point including Euclidean coordinates, barycentric coordinates, FaceId and squared distance to point or std::nullopt if no mesh point is found in the ball with sqrt(maxDistSq) radius around given point </dd></dl>

</div>
</div>
<a id="a973baf90b80dc2696bc083577727d4fc" name="a973baf90b80dc2696bc083577727d4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973baf90b80dc2696bc083577727d4fc">&#9670;&#160;</a></span>projectPoint() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::Mesh::projectPoint </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maxDistSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>finds the closest mesh point on this mesh (or its region) to given point; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>source location to look the closest to </td></tr>
    <tr><td class="paramname">res</td><td>found closest point including Euclidean coordinates, barycentric coordinates, FaceId and squared distance to point </td></tr>
    <tr><td class="paramname">maxDistSq</td><td>search only in the ball with sqrt(maxDistSq) radius around given point, smaller value here increases performance </td></tr>
    <tr><td class="paramname">xf</td><td>is mesh-to-point transformation, if not specified then identity transformation is assumed and works much faster; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if no mesh point is found in the ball with sqrt(maxDistSq) radius around given point </dd></dl>

</div>
</div>
<a id="a726a27c8dbdef71902d1031424bea5cf" name="a726a27c8dbdef71902d1031424bea5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726a27c8dbdef71902d1031424bea5cf">&#9670;&#160;</a></span>projectPoint() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::Mesh::projectPoint </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMR_1_1PointOnFace.html">PointOnFace</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maxDistSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>finds the closest mesh point on this mesh (or its region) to given point; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>source location to look the closest to </td></tr>
    <tr><td class="paramname">res</td><td>found closest point including Euclidean coordinates and FaceId </td></tr>
    <tr><td class="paramname">maxDistSq</td><td>search only in the ball with sqrt(maxDistSq) radius around given point, smaller value here increases performance </td></tr>
    <tr><td class="paramname">xf</td><td>is mesh-to-point transformation, if not specified then identity transformation is assumed and works much faster; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if no mesh point is found in the ball with sqrt(maxDistSq) radius around given point </dd></dl>

</div>
</div>
<a id="ada333ee4f3b0edfa859e5f8ee5a1c1f1" name="ada333ee4f3b0edfa859e5f8ee5a1c1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada333ee4f3b0edfa859e5f8ee5a1c1f1">&#9670;&#160;</a></span>pseudonormal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f MR::Mesh::pseudonormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns pseudonormal in corresponding face/edge/vertex for signed distance calculation; <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.9173&rep=rep1&type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.9173&amp;rep=rep1&amp;type=pdf</a> unlike <a class="el" href="namespaceMR.html#a09f9590ed4411f71af1c1526458d5dd1afea087517c26fadd409bd4b9dc642555">normal( const MeshTriPoint &amp; p )</a>, this is not a smooth function </p>

</div>
</div>
<a id="a33d264981ad277abb011e94a67cd5e4e" name="a33d264981ad277abb011e94a67cd5e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d264981ad277abb011e94a67cd5e4e">&#9670;&#160;</a></span>pseudonormal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f MR::Mesh::pseudonormal </td>
          <td>(</td>
          <td class="paramtype">UndirectedEdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes normalized half sum of face normals sharing given edge (only (region) faces will be considered); </p>

</div>
</div>
<a id="a3f0764fd9acf9f3a4b060a658c656efc" name="a3f0764fd9acf9f3a4b060a658c656efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0764fd9acf9f3a4b060a658c656efc">&#9670;&#160;</a></span>pseudonormal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f MR::Mesh::pseudonormal </td>
          <td>(</td>
          <td class="paramtype">VertId</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes angle-weighted sum of normals of incident faces of given vertex (only (region) faces will be considered); the sum is normalized before returning </p>

</div>
</div>
<a id="aa0cb7cda413178e311cd23632d44a07f" name="aa0cb7cda413178e311cd23632d44a07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cb7cda413178e311cd23632d44a07f">&#9670;&#160;</a></span>quadraticForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> QuadraticForm3f MR::Mesh::quadraticForm </td>
          <td>(</td>
          <td class="paramtype">VertId</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UndirectedEdgeBitSet *</td>          <td class="paramname"><span class="paramname"><em>creases</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes quadratic form in the vertex as the sum of squared distances from 1) planes of adjacent triangles 2) lines of adjacent boundary and crease edges </p>

</div>
</div>
<a id="a12917935a6261c2bbffbcc979a91abde" name="a12917935a6261c2bbffbcc979a91abde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12917935a6261c2bbffbcc979a91abde">&#9670;&#160;</a></span>shrinkToFit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::shrinkToFit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>requests the removal of unused capacity </p>

</div>
</div>
<a id="a879abd4325e74e6c17acebe255877c83" name="a879abd4325e74e6c17acebe255877c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879abd4325e74e6c17acebe255877c83">&#9670;&#160;</a></span>signedDistance() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::signedDistance </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>given a point (pt) in 3D, computes the closest point on mesh, and </p><dl class="section return"><dt>Returns</dt><dd>signed distance from pt to mesh: positive value - outside mesh, negative - inside mesh; this method can return wrong sign if the closest point is located on self-intersecting part of the mesh </dd></dl>

</div>
</div>
<a id="a0095216b1fbe49128eb4b14d6c9f8a42" name="a0095216b1fbe49128eb4b14d6c9f8a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0095216b1fbe49128eb4b14d6c9f8a42">&#9670;&#160;</a></span>signedDistance() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::signedDistance </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>given a point (pt) in 3D and the closest point to in on mesh (proj), </p><dl class="section return"><dt>Returns</dt><dd>signed distance from pt to mesh: positive value - outside mesh, negative - inside mesh; this method can return wrong sign if the closest point is located on self-intersecting part of the mesh </dd></dl>

</div>
</div>
<a id="a24304bcd9afe5cdb84be4ee761a8fb2f" name="a24304bcd9afe5cdb84be4ee761a8fb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24304bcd9afe5cdb84be4ee761a8fb2f">&#9670;&#160;</a></span>signedDistance() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::signedDistance </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4048484ac2e78090960bc9bbc60cd6b6" name="a4048484ac2e78090960bc9bbc60cd6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4048484ac2e78090960bc9bbc60cd6b6">&#9670;&#160;</a></span>signedDistance() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; float &gt; MR::Mesh::signedDistance </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maxDistSq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>given a point (pt) in 3D, computes the closest point on mesh, and </p><dl class="section return"><dt>Returns</dt><dd>signed distance from pt to mesh: positive value - outside mesh, negative - inside mesh; or std::nullopt if the projection point is not within maxDist; this method can return wrong sign if the closest point is located on self-intersecting part of the mesh </dd></dl>

</div>
</div>
<a id="a7444cb052e8855eb1ea69b34d2796f3a" name="a7444cb052e8855eb1ea69b34d2796f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7444cb052e8855eb1ea69b34d2796f3a">&#9670;&#160;</a></span>splitEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> EdgeId MR::Mesh::splitEdge </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>newVertPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a93482f559c684be16c718d5acd291d3e">FaceHashMap</a> *</td>          <td class="paramname"><span class="paramname"><em>new2Old</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>split given edge on two parts: dest(returned-edge) = org(e) - newly created vertex, org(returned-edge) = org(e-before-split), dest(e) = dest(e-before-split)</p>
<p>left and right faces of given edge if valid are also subdivided on two parts each; if left or right faces of the original edge were in the region, then include new parts of these faces in the region </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new2Old</td><td>receive mapping from newly appeared triangle to its original triangle (part to full) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a572820417c5fc8e867bbb2f078275222" name="a572820417c5fc8e867bbb2f078275222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572820417c5fc8e867bbb2f078275222">&#9670;&#160;</a></span>splitEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeId MR::Mesh::splitEdge </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a93482f559c684be16c718d5acd291d3e">FaceHashMap</a> *</td>          <td class="paramname"><span class="paramname"><em>new2Old</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4678592f5a58aba37a0994f895ff7804" name="a4678592f5a58aba37a0994f895ff7804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4678592f5a58aba37a0994f895ff7804">&#9670;&#160;</a></span>splitFace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId MR::Mesh::splitFace </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>newVertPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a93482f559c684be16c718d5acd291d3e">FaceHashMap</a> *</td>          <td class="paramname"><span class="paramname"><em>new2Old</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>split given triangle on three triangles, introducing new vertex with given coordinates and connecting it to original triangle vertices; if region is given, then it must include (f) and new faces will be added there as well </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new2Old</td><td>receive mapping from newly appeared triangle to its original triangle (part to full) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c0879122a6abf7e015c89fdbd7dd584" name="a8c0879122a6abf7e015c89fdbd7dd584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0879122a6abf7e015c89fdbd7dd584">&#9670;&#160;</a></span>splitFace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VertId MR::Mesh::splitFace </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMR.html#a93482f559c684be16c718d5acd291d3e">FaceHashMap</a> *</td>          <td class="paramname"><span class="paramname"><em>new2Old</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9168ca386aa3a34b0c1b79ddd7f4faa3" name="a9168ca386aa3a34b0c1b79ddd7f4faa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9168ca386aa3a34b0c1b79ddd7f4faa3">&#9670;&#160;</a></span>sumAngles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::sumAngles </td>
          <td>(</td>
          <td class="paramtype">VertId</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>outBoundaryVert</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the sum of triangle angles at given vertex; optionally returns whether the vertex is on boundary </p>

</div>
</div>
<a id="aa96011e8aa47330e9f075bc4ef3a08e2" name="aa96011e8aa47330e9f075bc4ef3a08e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96011e8aa47330e9f075bc4ef3a08e2">&#9670;&#160;</a></span>toEdgePoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a8ffb37085bbd6060f17bcf222941ab8c">MeshEdgePoint</a> MR::Mesh::toEdgePoint </td>
          <td>(</td>
          <td class="paramtype">EdgeId</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts edge and 3d point into edge-point representation </p>

</div>
</div>
<a id="add7ed762df9371522b37dc2b15689234" name="add7ed762df9371522b37dc2b15689234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7ed762df9371522b37dc2b15689234">&#9670;&#160;</a></span>toEdgePoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="namespaceMR.html#a8ffb37085bbd6060f17bcf222941ab8c">MeshEdgePoint</a> MR::Mesh::toEdgePoint </td>
          <td>(</td>
          <td class="paramtype">VertId</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts vertex into edge-point representation </p>

</div>
</div>
<a id="a98ce30cba5543afc4736d287bfd3d3bc" name="a98ce30cba5543afc4736d287bfd3d3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ce30cba5543afc4736d287bfd3d3bc">&#9670;&#160;</a></span>toTriPoint() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> MR::Mesh::toTriPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointOnFace.html">PointOnFace</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts face id and 3d point into barycentric representation </p>

</div>
</div>
<a id="ab3275b6e90cf7c761fd228b9bc6fefeb" name="ab3275b6e90cf7c761fd228b9bc6fefeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3275b6e90cf7c761fd228b9bc6fefeb">&#9670;&#160;</a></span>toTriPoint() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> MR::Mesh::toTriPoint </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts face id and 3d point into barycentric representation </p>

</div>
</div>
<a id="a25d99831d2f44ba34b7678c921475088" name="a25d99831d2f44ba34b7678c921475088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d99831d2f44ba34b7678c921475088">&#9670;&#160;</a></span>toTriPoint() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> MR::Mesh::toTriPoint </td>
          <td>(</td>
          <td class="paramtype">VertId</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts vertex into barycentric representation </p>

</div>
</div>
<a id="a9295908f703adbacd9b9b8f900b85f7d" name="a9295908f703adbacd9b9b8f900b85f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9295908f703adbacd9b9b8f900b85f7d">&#9670;&#160;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::transform </td>
          <td>(</td>
          <td class="paramtype">const AffineXf3f &amp;</td>          <td class="paramname"><span class="paramname"><em>xf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>applies given transformation to specified vertices if region is nullptr, all valid mesh vertices are used </p>

</div>
</div>
<a id="a49f7db0c7ecd59955478746c13609ff6" name="a49f7db0c7ecd59955478746c13609ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f7db0c7ecd59955478746c13609ff6">&#9670;&#160;</a></span>triangleAspectRatio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::Mesh::triangleAspectRatio </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns aspect ratio of given mesh triangle equal to the ratio of the circum-radius to twice its in-radius </p>

</div>
</div>
<a id="a9fc962b114f068665a1f40c936f26724" name="a9fc962b114f068665a1f40c936f26724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc962b114f068665a1f40c936f26724">&#9670;&#160;</a></span>triCenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f MR::Mesh::triCenter </td>
          <td>(</td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the centroid of given triangle </p>

</div>
</div>
<a id="a243ed2368ebb1f7bfaa1d71cef8a3d16" name="a243ed2368ebb1f7bfaa1d71cef8a3d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243ed2368ebb1f7bfaa1d71cef8a3d16">&#9670;&#160;</a></span>triPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> Vector3f MR::Mesh::triPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MeshTriPoint.html">MeshTriPoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes coordinates of point given as face and barycentric representation </p>

</div>
</div>
<a id="ad64499dab83be6cf5433119a613d6953" name="ad64499dab83be6cf5433119a613d6953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64499dab83be6cf5433119a613d6953">&#9670;&#160;</a></span>updateCaches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::updateCaches </td>
          <td>(</td>
          <td class="paramtype">const VertBitSet &amp;</td>          <td class="paramname"><span class="paramname"><em>changedVerts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>updates existing caches in case of few vertices were changed insignificantly, and topology remained unchanged; it shall be considered as a faster alternative to <a class="el" href="#ac4cfa4d1a1f01bbcf883f4e96079e505">invalidateCaches()</a> and following rebuild of trees </p>

</div>
</div>
<a id="a952176d5bcd16b91d26dc6fa2a0bdc6c" name="a952176d5bcd16b91d26dc6fa2a0bdc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952176d5bcd16b91d26dc6fa2a0bdc6c">&#9670;&#160;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> double MR::Mesh::volume </td>
          <td>(</td>
          <td class="paramtype">const FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns volume of closed mesh region, if region is not closed DBL_MAX is returned if region is nullptr - whole mesh is region </p>

</div>
</div>
<a id="a540a6eef456f6c54c214766fc0a7c3fb" name="a540a6eef456f6c54c214766fc0a7c3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540a6eef456f6c54c214766fc0a7c3fb">&#9670;&#160;</a></span>zeroUnusedPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::Mesh::zeroUnusedPoints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for all points not in topology.getValidVerts() sets coordinates to (0,0,0) </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9c8ead50efe2f8a111848b488f0a6aca" name="a9c8ead50efe2f8a111848b488f0a6aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8ead50efe2f8a111848b488f0a6aca">&#9670;&#160;</a></span>points</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VertCoords MR::Mesh::points</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91b13898794821d7f88845ebaa6cc1c4" name="a91b13898794821d7f88845ebaa6cc1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b13898794821d7f88845ebaa6cc1c4">&#9670;&#160;</a></span>topology</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> MR::Mesh::topology</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="MRMesh_2MRMesh_8h_source.html">MRMesh/MRMesh.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceMR.html">MR</a></li><li class="navelem"><a class="el" href="structMR_1_1Mesh.html">Mesh</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
