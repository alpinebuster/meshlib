<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta name="robots" content="noindex"/>
<script type="text/javascript">
  !function () {
    var currentHost = window.location.hostname;
    var currentPath = window.location.pathname;
    if (currentHost === 'meshinspector.github.io' && !currentPath.includes('/MeshLib/dev/')) {
      var newPath = currentPath.replace('/MeshLib/html', '/documentation');
      var newURL = 'https://meshlib.io' + newPath + window.location.search + window.location.hash;
      window.location.replace(newURL);
    }
  }();
</script>
<script>
  !function(){var i="analytics",analytics=window[i]=window[i]||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","screen","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware","register"];analytics.factory=function(e){return function(){if(window[i].initialized)return window[i][e].apply(window[i],arguments);var n=Array.prototype.slice.call(arguments);if(["track","screen","alias","group","page","identify"].indexOf(e)>-1){var c=document.querySelector("link[rel='canonical']");n.push({__t:"bpc",c:c&&c.getAttribute("href")||void 0,p:location.pathname,u:location.href,s:location.search,t:document.title,r:document.referrer})}n.unshift(e);analytics.push(n);return analytics}};for(var n=0;n<analytics.methods.length;n++){var key=analytics.methods[n];analytics[key]=analytics.factory(key)}analytics.load=function(key,n){var t=document.createElement("script");t.type="text/javascript";t.async=!0;t.setAttribute("data-global-segment-analytics-key",i);t.src="https://cdn.segment.com/analytics.js/v1/" + key + "/analytics.min.js";var r=document.getElementsByTagName("script")[0];r.parentNode.insertBefore(t,r);analytics._loadOptions=n};analytics._writeKey="Fi7y6F1GgFvTTomYo8zvETBoGHkDDxGx";;analytics.SNIPPET_VERSION="5.2.0";
  analytics.load("Fi7y6F1GgFvTTomYo8zvETBoGHkDDxGx");
  analytics.page();
  }}();
</script>
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-MBPLX27B');</script>
  <!-- End Google Tag Manager -->
<meta name="robots" content="noindex, nofollow">
 <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshLib C++ Docs: Mesh Segmentation overwiev</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CustomStyle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
    DoxygenAwesomeTabs.init()
</script>
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MBPLX27B"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><a href="https://meshlib.io/"><img alt="Logo" src="favicon.ico"/></a></td>
  <td id="projectalign">
   <div id="projectname">MeshLib C++ Docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__MeshSegmentationGroup.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Mesh Segmentation overwiev</div></div>
</div><!--header-->
<div class="contents">

<p>A set of functions for selecting segments on a mesh.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6411ded50ca303d4fa4228137d695d43" id="r_ga6411ded50ca303d4fa4228137d695d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> FaceBitSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6411ded50ca303d4fa4228137d695d43">MR::fillContourLeftByGraphCut</a> (const <a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;topology, const <a class="elRef" href="../namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &amp;contour, const <a class="elRef" href="../namespaceMR.html#a89c45ed75d3ee7e49964d4afe5a64651">EdgeMetric</a> &amp;metric)</td></tr>
<tr class="memdesc:ga6411ded50ca303d4fa4228137d695d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills region located to the left from given contour, by minimizing the sum of metric over the boundary.  <br /></td></tr>
<tr class="separator:ga6411ded50ca303d4fa4228137d695d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga771908317b966d8e9e45af1cc448756e" id="r_ga771908317b966d8e9e45af1cc448756e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> FaceBitSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga771908317b966d8e9e45af1cc448756e">MR::fillContourLeftByGraphCut</a> (const <a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;topology, const std::vector&lt; <a class="elRef" href="../namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;contours, const <a class="elRef" href="../namespaceMR.html#a89c45ed75d3ee7e49964d4afe5a64651">EdgeMetric</a> &amp;metric)</td></tr>
<tr class="memdesc:ga771908317b966d8e9e45af1cc448756e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills region located to the left from given contours, by minimizing the sum of metric over the boundary.  <br /></td></tr>
<tr class="separator:ga771908317b966d8e9e45af1cc448756e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94134d6a12381a36151563fe8472f818" id="r_ga94134d6a12381a36151563fe8472f818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> FaceBitSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga94134d6a12381a36151563fe8472f818">MR::segmentByGraphCut</a> (const <a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;topology, const FaceBitSet &amp;source, const FaceBitSet &amp;sink, const <a class="elRef" href="../namespaceMR.html#a89c45ed75d3ee7e49964d4afe5a64651">EdgeMetric</a> &amp;metric)</td></tr>
<tr class="memdesc:ga94134d6a12381a36151563fe8472f818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds segment that divide mesh on source and sink (source included, sink excluded), by minimizing the sum of metric over the boundary.  <br /></td></tr>
<tr class="separator:ga94134d6a12381a36151563fe8472f818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92dbf357e425dd6e8d7f76ab544250c5" id="r_ga92dbf357e425dd6e8d7f76ab544250c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; <a class="elRef" href="../namespaceMR.html#a099da1b4cb4b8348ee3fed0588b01aa3">EdgeLoop</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga92dbf357e425dd6e8d7f76ab544250c5">MR::surroundingContour</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, std::vector&lt; EdgeId &gt; includeEdges, const <a class="elRef" href="../namespaceMR.html#a89c45ed75d3ee7e49964d4afe5a64651">EdgeMetric</a> &amp;edgeMetric, const Vector3f &amp;dir)</td></tr>
<tr class="memdesc:ga92dbf357e425dd6e8d7f76ab544250c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best closed edge loop passing through given edges, which minimizes the sum of given edge metric. The algorithm assumes that input edges can be projected on the plane orthogonal to given direction, then the center point of all input edges is found, and each segment of the searched loop is within infinite pie sector with this center and the borders passing via two sorted input edges.  <br /></td></tr>
<tr class="separator:ga92dbf357e425dd6e8d7f76ab544250c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f96f1d3fde9a79a2d6925cf6ba77f8d" id="r_ga0f96f1d3fde9a79a2d6925cf6ba77f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; <a class="elRef" href="../namespaceMR.html#a099da1b4cb4b8348ee3fed0588b01aa3">EdgeLoop</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f96f1d3fde9a79a2d6925cf6ba77f8d">MR::surroundingContour</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, std::vector&lt; VertId &gt; keyVertices, const <a class="elRef" href="../namespaceMR.html#a89c45ed75d3ee7e49964d4afe5a64651">EdgeMetric</a> &amp;edgeMetric, const Vector3f &amp;dir)</td></tr>
<tr class="memdesc:ga0f96f1d3fde9a79a2d6925cf6ba77f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best closed edge loop passing through given vertices, which minimizes the sum of given edge metric. The algorithm assumes that input vertices can be projected on the plane orthogonal to given direction, then the center point of all input vertices is found, and each segment of the searched loop is within infinite pie sector with this center and the borders passing via two sorted input vertices.  <br /></td></tr>
<tr class="separator:ga0f96f1d3fde9a79a2d6925cf6ba77f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A set of functions for selecting segments on a mesh. </p>
<h1><a class="anchor" id="MeshSegmentationGroup_HowTo"></a>
How To</h1>
<ol type="1">
<li>Make Contour(-s)<br  />
First step to get a mesh segment by two (/three) points, is getting the contour that bounds the segment.<br  />
To do this, you can use <a class="el" href="#ga92dbf357e425dd6e8d7f76ab544250c5">surroundingContour</a></li>
<li>Get Segment<br  />
For getting segment of mesh by contour(-s) use <a class="el" href="#ga6411ded50ca303d4fa4228137d695d43">fillContourLeftByGraphCut</a>.</li>
</ol>
<a class="anchor" id="fillContourLeftByGraphCut_examples"></a>
<table border="0">
<caption></caption>
<tr>
<td><div class="image">
<img src="mesh_segmentation_0.png" alt="" width="350cm"/>
<div class="caption">
Before</div></div>
 </td><td><div class="image">
<img src="mesh_segmentation_1.png" alt="" width="350cm"/>
<div class="caption">
After</div></div>
  </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6411ded50ca303d4fa4228137d695d43" name="ga6411ded50ca303d4fa4228137d695d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6411ded50ca303d4fa4228137d695d43">&#9670;&#160;</a></span>fillContourLeftByGraphCut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> FaceBitSet MR::fillContourLeftByGraphCut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>contour</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a89c45ed75d3ee7e49964d4afe5a64651">EdgeMetric</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>metric</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills region located to the left from given contour, by minimizing the sum of metric over the boundary. </p>

</div>
</div>
<a id="ga771908317b966d8e9e45af1cc448756e" name="ga771908317b966d8e9e45af1cc448756e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga771908317b966d8e9e45af1cc448756e">&#9670;&#160;</a></span>fillContourLeftByGraphCut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> FaceBitSet MR::fillContourLeftByGraphCut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="../namespaceMR.html#a9f6c1e614e45e332d4cecfc5e77bc07e">EdgePath</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>contours</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a89c45ed75d3ee7e49964d4afe5a64651">EdgeMetric</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>metric</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills region located to the left from given contours, by minimizing the sum of metric over the boundary. </p>

</div>
</div>
<a id="ga94134d6a12381a36151563fe8472f818" name="ga94134d6a12381a36151563fe8472f818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94134d6a12381a36151563fe8472f818">&#9670;&#160;</a></span>segmentByGraphCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> FaceBitSet MR::segmentByGraphCut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMR_1_1MeshTopology.html">MeshTopology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceBitSet &amp;</td>          <td class="paramname"><span class="paramname"><em>sink</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a89c45ed75d3ee7e49964d4afe5a64651">EdgeMetric</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>metric</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds segment that divide mesh on source and sink (source included, sink excluded), by minimizing the sum of metric over the boundary. </p>

</div>
</div>
<a id="ga92dbf357e425dd6e8d7f76ab544250c5" name="ga92dbf357e425dd6e8d7f76ab544250c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92dbf357e425dd6e8d7f76ab544250c5">&#9670;&#160;</a></span>surroundingContour() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; <a class="elRef" href="../namespaceMR.html#a099da1b4cb4b8348ee3fed0588b01aa3">EdgeLoop</a> &gt; MR::surroundingContour </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; EdgeId &gt;</td>          <td class="paramname"><span class="paramname"><em>includeEdges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a89c45ed75d3ee7e49964d4afe5a64651">EdgeMetric</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>edgeMetric</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the best closed edge loop passing through given edges, which minimizes the sum of given edge metric. The algorithm assumes that input edges can be projected on the plane orthogonal to given direction, then the center point of all input edges is found, and each segment of the searched loop is within infinite pie sector with this center and the borders passing via two sorted input edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">includeEdges</td><td>contain all edges in arbitrary order that must be present in the returned loop, probably with reversed direction (should have at least 2 elements) </td></tr>
    <tr><td class="paramname">edgeMetric</td><td>returned loop will minimize the sum of this metric </td></tr>
    <tr><td class="paramname">dir</td><td>direction approximately orthogonal to the loop, the resulting loop will be oriented clockwise if look from the direction's tip </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f96f1d3fde9a79a2d6925cf6ba77f8d" name="ga0f96f1d3fde9a79a2d6925cf6ba77f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f96f1d3fde9a79a2d6925cf6ba77f8d">&#9670;&#160;</a></span>surroundingContour() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; <a class="elRef" href="../namespaceMR.html#a099da1b4cb4b8348ee3fed0588b01aa3">EdgeLoop</a> &gt; MR::surroundingContour </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VertId &gt;</td>          <td class="paramname"><span class="paramname"><em>keyVertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a89c45ed75d3ee7e49964d4afe5a64651">EdgeMetric</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>edgeMetric</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the best closed edge loop passing through given vertices, which minimizes the sum of given edge metric. The algorithm assumes that input vertices can be projected on the plane orthogonal to given direction, then the center point of all input vertices is found, and each segment of the searched loop is within infinite pie sector with this center and the borders passing via two sorted input vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyVertices</td><td>contain all vertices in arbitrary order that returned loop must pass (should have at least 2 elements) </td></tr>
    <tr><td class="paramname">edgeMetric</td><td>returned loop will minimize the sum of this metric </td></tr>
    <tr><td class="paramname">dir</td><td>direction approximately orthogonal to the loop, the resulting loop will be oriented clockwise if look from the direction's tip </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.11.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a rel="nofollow" href="https://www.doxygen.nl/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
