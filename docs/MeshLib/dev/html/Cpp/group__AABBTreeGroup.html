<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta name="robots" content="noindex"/>
<script type="text/javascript">
  !function () {
    var currentHost = window.location.hostname;
    var currentPath = window.location.pathname;
    if (currentHost === 'meshinspector.github.io' && !currentPath.includes('/MeshLib/dev/')) {
      var newPath = currentPath.replace('/MeshLib/html', '/documentation');
      var newURL = 'https://meshlib.io' + newPath + window.location.search + window.location.hash;
      window.location.replace(newURL);
    }
  }();
</script>
<script>
  !function(){var i="analytics",analytics=window[i]=window[i]||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","screen","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware","register"];analytics.factory=function(e){return function(){if(window[i].initialized)return window[i][e].apply(window[i],arguments);var n=Array.prototype.slice.call(arguments);if(["track","screen","alias","group","page","identify"].indexOf(e)>-1){var c=document.querySelector("link[rel='canonical']");n.push({__t:"bpc",c:c&&c.getAttribute("href")||void 0,p:location.pathname,u:location.href,s:location.search,t:document.title,r:document.referrer})}n.unshift(e);analytics.push(n);return analytics}};for(var n=0;n<analytics.methods.length;n++){var key=analytics.methods[n];analytics[key]=analytics.factory(key)}analytics.load=function(key,n){var t=document.createElement("script");t.type="text/javascript";t.async=!0;t.setAttribute("data-global-segment-analytics-key",i);t.src="https://cdn.segment.com/analytics.js/v1/" + key + "/analytics.min.js";var r=document.getElementsByTagName("script")[0];r.parentNode.insertBefore(t,r);analytics._loadOptions=n};analytics._writeKey="Fi7y6F1GgFvTTomYo8zvETBoGHkDDxGx";;analytics.SNIPPET_VERSION="5.2.0";
  analytics.load("Fi7y6F1GgFvTTomYo8zvETBoGHkDDxGx");
  analytics.page();
  }}();
</script>
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-MBPLX27B');</script>
  <!-- End Google Tag Manager -->
<meta name="robots" content="noindex, nofollow">
 <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshLib C++ Docs: AABB Tree overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CustomStyle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
    DoxygenAwesomeTabs.init()
</script>
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MBPLX27B"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><a href="https://meshlib.io/"><img alt="Logo" src="favicon.ico"/></a></td>
  <td id="projectalign">
   <div id="projectname">MeshLib C++ Docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__AABBTreeGroup.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">AABB Tree overview</div></div>
</div><!--header-->
<div class="contents">

<p>This chapter represents documentation about AABB Tree.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1Cuda_1_1FastWindingNumber.html">MR::Cuda::FastWindingNumber</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1AABBTree.html">MR::AABBTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1BoxedLeaf.html">MR::BoxedLeaf&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1AABBTreeTraits.html">MR::AABBTreeTraits&lt; L, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1AABBTreeNode.html">MR::AABBTreeNode&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1NodeNode.html">MR::NodeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1AABBTreeObjects.html">MR::AABBTreeObjects</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1AABBTreePoints.html">MR::AABBTreePoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">bounding volume hierarchy for point cloud structure  <a href="classMR_1_1AABBTreePoints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PolylineTraits.html">MR::PolylineTraits&lt; V &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PolylineTraits_3_01Vector2f_01_4.html">MR::PolylineTraits&lt; Vector2f &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PolylineTraits_3_01Vector3f_01_4.html">MR::PolylineTraits&lt; Vector3f &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1AABBTreePolyline.html">MR::AABBTreePolyline&lt; V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">bounding volume hierarchy for line segments  <a href="classMR_1_1AABBTreePolyline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1FaceFace.html">MR::FaceFace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1UndirectedEdgeUndirectedEdge.html">MR::UndirectedEdgeUndirectedEdge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1FastWindingNumber.html">MR::FastWindingNumber</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1IntersectionPrecomputes2.html">MR::IntersectionPrecomputes2&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1EdgeTri.html">MR::EdgeTri</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge from one mesh and triangle from another mesh  <a href="structMR_1_1EdgeTri.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PreciseCollisionResult.html">MR::PreciseCollisionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MeshIntersectionResult.html">MR::MeshIntersectionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MultiRayMeshIntersectResult.html">MR::MultiRayMeshIntersectResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MultiMeshIntersectionResult.html">MR::MultiMeshIntersectionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1Line3Mesh.html">MR::Line3Mesh&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MeshMeshDistanceResult.html">MR::MeshMeshDistanceResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MeshMeshSignedDistanceResult.html">MR::MeshMeshSignedDistanceResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MeshProjectionResult.html">MR::MeshProjectionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1MeshProjectionTransforms.html">MR::MeshProjectionTransforms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1SignedDistanceToMeshResult.html">MR::SignedDistanceToMeshResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PointsProjectionResult.html">MR::PointsProjectionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1FindProjectionOnPointsSettings.html">MR::FindProjectionOnPointsSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">settings for <a class="el" href="classMR_1_1IPointsProjector.html#a73d0b887b876f110e3fb6554422f9a31">IPointsProjector::findProjections</a>  <a href="structMR_1_1FindProjectionOnPointsSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1IPointsProjector.html">MR::IPointsProjector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract class for computing the closest points of point clouds  <a href="classMR_1_1IPointsProjector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1PointsProjector.html">MR::PointsProjector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default implementation of <a class="el" href="classMR_1_1IPointsProjector.html" title="abstract class for computing the closest points of point clouds">IPointsProjector</a>  <a href="classMR_1_1PointsProjector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PolylineProjectionResult.html">MR::PolylineProjectionResult&lt; V &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PolylineProjectionResult3Arg.html">MR::PolylineProjectionResult3Arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMR_1_1PolylineProjectionWithOffsetResult.html">MR::PolylineProjectionWithOffsetResult&lt; V &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1SharedThreadSafeOwner.html">MR::SharedThreadSafeOwner&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMR_1_1UniqueThreadSafeOwner.html">MR::UniqueThreadSafeOwner&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2d9f9e10f5365b971c9f7300264be632" id="r_ga2d9f9e10f5365b971c9f7300264be632"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2d9f9e10f5365b971c9f7300264be632">MR::FaceTreeTraits3</a> = <a class="el" href="structMR_1_1AABBTreeTraits.html">AABBTreeTraits</a>&lt;<a class="elRef" href="../namespaceMR.html#a7a4a96848eb4b1524be699a7adcd8017">FaceTag</a>, Box3f&gt;</td></tr>
<tr class="separator:ga2d9f9e10f5365b971c9f7300264be632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876e325460f0c5460c1e453324ca329c" id="r_ga876e325460f0c5460c1e453324ca329c"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ga876e325460f0c5460c1e453324ca329c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga876e325460f0c5460c1e453324ca329c">MR::LineTreeTraits</a> = <a class="el" href="structMR_1_1AABBTreeTraits.html">AABBTreeTraits</a>&lt;<a class="elRef" href="../namespaceMR.html#a1bbe6aa7d7136f740286af86f591c19b">UndirectedEdgeTag</a>, <a class="el" href="structMR_1_1Box.html">Box</a>&lt;V&gt;&gt;</td></tr>
<tr class="separator:ga876e325460f0c5460c1e453324ca329c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346d2e7774495e3e4ca05a2325f11aaf" id="r_ga346d2e7774495e3e4ca05a2325f11aaf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga346d2e7774495e3e4ca05a2325f11aaf">MR::LineTreeTraits2</a> = <a class="el" href="#ga876e325460f0c5460c1e453324ca329c">LineTreeTraits</a>&lt;Vector2f&gt;</td></tr>
<tr class="separator:ga346d2e7774495e3e4ca05a2325f11aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6e57b5e87718397acc1762969ad77a" id="r_gacf6e57b5e87718397acc1762969ad77a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacf6e57b5e87718397acc1762969ad77a">MR::LineTreeTraits3</a> = <a class="el" href="#ga876e325460f0c5460c1e453324ca329c">LineTreeTraits</a>&lt;Vector3f&gt;</td></tr>
<tr class="separator:gacf6e57b5e87718397acc1762969ad77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c75e3c26967a90edbe075a77cb2ca9" id="r_ga01c75e3c26967a90edbe075a77cb2ca9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga01c75e3c26967a90edbe075a77cb2ca9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga01c75e3c26967a90edbe075a77cb2ca9">MR::AABBTreeNodeVec</a> = <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt;<a class="el" href="structMR_1_1AABBTreeNode.html">AABBTreeNode</a>&lt;T&gt;, NodeId&gt;</td></tr>
<tr class="separator:ga01c75e3c26967a90edbe075a77cb2ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga285ea5cd9fb638c90fec0099f526c057" id="r_ga285ea5cd9fb638c90fec0099f526c057"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga285ea5cd9fb638c90fec0099f526c057">MR::TriangleCallback</a> = std::function&lt;<a class="el" href="#ga3dd2fd9fcc06b6502d22a9ea3eb63e47">ProcessOneResult</a>( const Vector3f &amp; p, FaceId f, const Vector3f &amp; q, float distSq )&gt;</td></tr>
<tr class="separator:ga285ea5cd9fb638c90fec0099f526c057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9222ec2d954badb7ee5874321a084eb6" id="r_ga9222ec2d954badb7ee5874321a084eb6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9222ec2d954badb7ee5874321a084eb6">MR::Line3fMesh</a> = <a class="el" href="structMR_1_1Line3Mesh.html">Line3Mesh</a>&lt;float&gt;</td></tr>
<tr class="separator:ga9222ec2d954badb7ee5874321a084eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba650839d7806773bb542b986ac4283" id="r_ga8ba650839d7806773bb542b986ac4283"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8ba650839d7806773bb542b986ac4283">MR::Line3dMesh</a> = <a class="el" href="structMR_1_1Line3Mesh.html">Line3Mesh</a>&lt;double&gt;</td></tr>
<tr class="separator:ga8ba650839d7806773bb542b986ac4283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac20cf6ba073a7db1e2df313fb87d9517" id="r_gac20cf6ba073a7db1e2df313fb87d9517"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac20cf6ba073a7db1e2df313fb87d9517">MR::MeshIntersectionCallback</a> = std::function&lt;bool(const <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a> &amp;)&gt;</td></tr>
<tr class="separator:gac20cf6ba073a7db1e2df313fb87d9517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4349e23b1c03bbeb120c81f3cbb8b615" id="r_ga4349e23b1c03bbeb120c81f3cbb8b615"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4349e23b1c03bbeb120c81f3cbb8b615">MR::FoundBoxedTriCallback</a> = std::function&lt;<a class="elRef" href="../namespaceMR.html#ae9fc4543eb3302ae33b7843707485149">Processing</a>( FaceId found, Ball3f &amp; ball )&gt;</td></tr>
<tr class="separator:ga4349e23b1c03bbeb120c81f3cbb8b615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fa10deed3f5f765a28d62f2a9667c0f" id="r_ga3fa10deed3f5f765a28d62f2a9667c0f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3fa10deed3f5f765a28d62f2a9667c0f">MR::FoundTriCallback</a> = std::function&lt;<a class="elRef" href="../namespaceMR.html#ae9fc4543eb3302ae33b7843707485149">Processing</a>( const <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp; found, Ball3f &amp; ball )&gt;</td></tr>
<tr class="memdesc:ga3fa10deed3f5f765a28d62f2a9667c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">this callback is invoked on every triangle at least partially in the ball, and allows changing (shrinking only) the ball  <br /></td></tr>
<tr class="separator:ga3fa10deed3f5f765a28d62f2a9667c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2b944209dd41b786a30b1d537639470" id="r_gac2b944209dd41b786a30b1d537639470"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:gac2b944209dd41b786a30b1d537639470"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac2b944209dd41b786a30b1d537639470">MR::FoundEdgeCallback</a> = std::function&lt;void( UndirectedEdgeId, const V&amp; closestPt, float distSq )&gt;</td></tr>
<tr class="separator:gac2b944209dd41b786a30b1d537639470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e0d9af4be57927671a26f2c4588a515" id="r_ga5e0d9af4be57927671a26f2c4588a515"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5e0d9af4be57927671a26f2c4588a515">MR::FoundEdgeCallback2</a> = <a class="el" href="#gac2b944209dd41b786a30b1d537639470">FoundEdgeCallback</a>&lt;Vector2f&gt;</td></tr>
<tr class="separator:ga5e0d9af4be57927671a26f2c4588a515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga865abfe228b7d60d582d2c6ce24ffb19" id="r_ga865abfe228b7d60d582d2c6ce24ffb19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga865abfe228b7d60d582d2c6ce24ffb19">MR::FoundEdgeCallback3</a> = <a class="el" href="#gac2b944209dd41b786a30b1d537639470">FoundEdgeCallback</a>&lt;Vector3f&gt;</td></tr>
<tr class="separator:ga865abfe228b7d60d582d2c6ce24ffb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3dd2fd9fcc06b6502d22a9ea3eb63e47" id="r_ga3dd2fd9fcc06b6502d22a9ea3eb63e47"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3dd2fd9fcc06b6502d22a9ea3eb63e47">MR::ProcessOneResult</a> : bool { <a class="el" href="#gga3dd2fd9fcc06b6502d22a9ea3eb63e47a38e59feb928e37292c8ee0a50f447612">MR::ProcessOneResult::StopProcessing</a> = false
, <a class="el" href="#gga3dd2fd9fcc06b6502d22a9ea3eb63e47aab6bb60f51b25ae0f7ec450173e3348e">MR::ProcessOneResult::ContinueProcessing</a> = true
 }</td></tr>
<tr class="separator:ga3dd2fd9fcc06b6502d22a9ea3eb63e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3c1bb6417aaa769fa4156f2edac91749" id="r_ga3c1bb6417aaa769fa4156f2edac91749"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c1bb6417aaa769fa4156f2edac91749">MR::getNumNodes</a> (int numLeaves)</td></tr>
<tr class="memdesc:ga3c1bb6417aaa769fa4156f2edac91749"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of nodes in the binary tree with given number of leaves  <br /></td></tr>
<tr class="separator:ga3c1bb6417aaa769fa4156f2edac91749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364302ddaf673e7f00c6745f4172d6c0" id="r_ga364302ddaf673e7f00c6745f4172d6c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga364302ddaf673e7f00c6745f4172d6c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga01c75e3c26967a90edbe075a77cb2ca9">AABBTreeNodeVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga364302ddaf673e7f00c6745f4172d6c0">MR::makeAABBTreeNodeVec</a> (<a class="el" href="classMR_1_1Buffer.html">Buffer</a>&lt; <a class="el" href="structMR_1_1BoxedLeaf.html">BoxedLeaf</a>&lt; T &gt; &gt; boxedLeaves)</td></tr>
<tr class="separator:ga364302ddaf673e7f00c6745f4172d6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68e6755511856f1d2c49843267a81d4c" id="r_ga68e6755511856f1d2c49843267a81d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga68e6755511856f1d2c49843267a81d4c">MR::findDirMax</a> (const Vector3f &amp;dir, const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;m, <a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a> u=UseAABBTree::Yes)</td></tr>
<tr class="separator:ga68e6755511856f1d2c49843267a81d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49d29fe114a45e7ba44769ed23e07a7" id="r_gaf49d29fe114a45e7ba44769ed23e07a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf49d29fe114a45e7ba44769ed23e07a7">MR::findDirMax</a> (const Vector3f &amp;dir, const MeshPart &amp;mp, <a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a> u=UseAABBTree::Yes)</td></tr>
<tr class="separator:gaf49d29fe114a45e7ba44769ed23e07a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b086afbde5a06209437e0bf56bc6d9" id="r_gaa1b086afbde5a06209437e0bf56bc6d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa1b086afbde5a06209437e0bf56bc6d9">MR::findDirMax</a> (const Vector3f &amp;dir, const MeshVertPart &amp;mp, <a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a> u=UseAABBTree::Yes)</td></tr>
<tr class="separator:gaa1b086afbde5a06209437e0bf56bc6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ff2fe386af48055096b3eb89f158b6" id="r_gaa5ff2fe386af48055096b3eb89f158b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa5ff2fe386af48055096b3eb89f158b6">MR::findDirMax</a> (const Vector3f &amp;dir, const Polyline3 &amp;polyline, <a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a> u=UseAABBTree::Yes)</td></tr>
<tr class="separator:gaa5ff2fe386af48055096b3eb89f158b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650448329cde9ee6b4e27760630a09a1" id="r_ga650448329cde9ee6b4e27760630a09a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga650448329cde9ee6b4e27760630a09a1">MR::findDirMax</a> (const Vector2f &amp;dir, const Polyline2 &amp;polyline, <a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a> u=UseAABBTree::Yes)</td></tr>
<tr class="separator:ga650448329cde9ee6b4e27760630a09a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e2ad7a22a0bdbd4e16907bd521c654" id="r_ga66e2ad7a22a0bdbd4e16907bd521c654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga66e2ad7a22a0bdbd4e16907bd521c654">MR::findDirMax</a> (const Vector3f &amp;dir, const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;cloud, const VertBitSet *region=nullptr, <a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a> u=UseAABBTree::Yes)</td></tr>
<tr class="separator:ga66e2ad7a22a0bdbd4e16907bd521c654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga025c593a83827d6bf51e5df0acd27db5" id="r_ga025c593a83827d6bf51e5df0acd27db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga025c593a83827d6bf51e5df0acd27db5">MR::findDirMax</a> (const Vector3f &amp;dir, const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;tree, const VertBitSet *region=nullptr)</td></tr>
<tr class="separator:ga025c593a83827d6bf51e5df0acd27db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb33a674ea8b57ac858e40d42e26e3" id="r_ga7fcb33a674ea8b57ac858e40d42e26e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7fcb33a674ea8b57ac858e40d42e26e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7fcb33a674ea8b57ac858e40d42e26e3">MR::findMaxVectorDim</a> (int &amp;dimX, int &amp;dimY, int &amp;dimZ, const <a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt; T &gt; &amp;dir)</td></tr>
<tr class="memdesc:ga7fcb33a674ea8b57ac858e40d42e26e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds index of maximum axis and stores it into dimZ  <br /></td></tr>
<tr class="separator:ga7fcb33a674ea8b57ac858e40d42e26e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9984ed4cff38cd012243e835f02e0e92" id="r_ga9984ed4cff38cd012243e835f02e0e92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9984ed4cff38cd012243e835f02e0e92">MR::IntersectionPrecomputes&lt; T &gt;::IntersectionPrecomputes</a> ()=default</td></tr>
<tr class="separator:ga9984ed4cff38cd012243e835f02e0e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a5a2178c875139ca3e402c1a46324c" id="r_gac2a5a2178c875139ca3e402c1a46324c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac2a5a2178c875139ca3e402c1a46324c">MR::IntersectionPrecomputes&lt; T &gt;::IntersectionPrecomputes</a> (const <a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt; T &gt; &amp;dir)</td></tr>
<tr class="separator:gac2a5a2178c875139ca3e402c1a46324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga562052fddd56327be07ffe8c0cc7f7af" id="r_ga562052fddd56327be07ffe8c0cc7f7af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga562052fddd56327be07ffe8c0cc7f7af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga562052fddd56327be07ffe8c0cc7f7af">MR::findMaxVectorDim</a> (int &amp;dimX, int &amp;dimY, const <a class="el" href="structMR_1_1Vector2.html">Vector2</a>&lt; T &gt; &amp;dir)</td></tr>
<tr class="memdesc:ga562052fddd56327be07ffe8c0cc7f7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds index of maximum axis and stores it into dimY  <br /></td></tr>
<tr class="separator:ga562052fddd56327be07ffe8c0cc7f7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb209f0c917451a03debbf058fc39e6" id="r_gaaeb209f0c917451a03debbf058fc39e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1FaceFace.html">FaceFace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaeb209f0c917451a03debbf058fc39e6">MR::findCollidingTriangles</a> (const MeshPart &amp;a, const MeshPart &amp;b, const AffineXf3f *rigidB2A=nullptr, bool firstIntersectionOnly=false)</td></tr>
<tr class="memdesc:gaaeb209f0c917451a03debbf058fc39e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding triangles from two meshes or two mesh regions  <br /></td></tr>
<tr class="separator:gaaeb209f0c917451a03debbf058fc39e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e983a2ba53dbe6d49313488f3cae23" id="r_ga47e983a2ba53dbe6d49313488f3cae23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::pair&lt; FaceBitSet, FaceBitSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga47e983a2ba53dbe6d49313488f3cae23">MR::findCollidingTriangleBitsets</a> (const MeshPart &amp;a, const MeshPart &amp;b, const AffineXf3f *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga47e983a2ba53dbe6d49313488f3cae23"><td class="mdescLeft">&#160;</td><td class="mdescRight">the same as <a class="el" href="#gaaeb209f0c917451a03debbf058fc39e6">findCollidingTriangles</a>, but returns one bite set per mesh with colliding triangles  <br /></td></tr>
<tr class="separator:ga47e983a2ba53dbe6d49313488f3cae23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b56b2d80a7923ebfeed5757d334e4f" id="r_ga69b56b2d80a7923ebfeed5757d334e4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga69b56b2d80a7923ebfeed5757d334e4f">MR::findSelfCollidingTriangles</a> (const MeshPart &amp;mp, std::vector&lt; <a class="el" href="structMR_1_1FaceFace.html">FaceFace</a> &gt; *outCollidingPairs, <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> cb={}, const Face2RegionMap *regionMap=nullptr, bool touchIsIntersection=false)</td></tr>
<tr class="memdesc:ga69b56b2d80a7923ebfeed5757d334e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs (or the fact of any self-collision) of colliding triangles from one mesh or a region  <br /></td></tr>
<tr class="separator:ga69b56b2d80a7923ebfeed5757d334e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac96d312ea833414d4d74069169cb1b" id="r_ga0ac96d312ea833414d4d74069169cb1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; std::vector&lt; <a class="el" href="structMR_1_1FaceFace.html">FaceFace</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0ac96d312ea833414d4d74069169cb1b">MR::findSelfCollidingTriangles</a> (const MeshPart &amp;mp, <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> cb={}, const Face2RegionMap *regionMap=nullptr, bool touchIsIntersection=false)</td></tr>
<tr class="memdesc:ga0ac96d312ea833414d4d74069169cb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding triangles from one mesh or a region  <br /></td></tr>
<tr class="separator:ga0ac96d312ea833414d4d74069169cb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac946d92c431583fc7c4d656445ba1c07" id="r_gac946d92c431583fc7c4d656445ba1c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; FaceBitSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac946d92c431583fc7c4d656445ba1c07">MR::findSelfCollidingTrianglesBS</a> (const MeshPart &amp;mp, <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> cb={}, const Face2RegionMap *regionMap=nullptr, bool touchIsIntersection=false)</td></tr>
<tr class="memdesc:gac946d92c431583fc7c4d656445ba1c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">the same <a class="el" href="#ga69b56b2d80a7923ebfeed5757d334e4f">findSelfCollidingTriangles</a> but returns the union of all self-intersecting faces  <br /></td></tr>
<tr class="separator:gac946d92c431583fc7c4d656445ba1c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4d304b28fd4695d20dc454318f5660" id="r_ga3c4d304b28fd4695d20dc454318f5660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c4d304b28fd4695d20dc454318f5660">MR::isInside</a> (const MeshPart &amp;a, const MeshPart &amp;b, const AffineXf3f *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga3c4d304b28fd4695d20dc454318f5660"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks that arbitrary mesh part A is inside of closed mesh part B  <br /></td></tr>
<tr class="separator:ga3c4d304b28fd4695d20dc454318f5660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d53ebf69ce150861f17e4695543778" id="r_ga30d53ebf69ce150861f17e4695543778"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga30d53ebf69ce150861f17e4695543778">MR::isNonIntersectingInside</a> (const MeshPart &amp;a, const MeshPart &amp;b, const AffineXf3f *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga30d53ebf69ce150861f17e4695543778"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks that arbitrary mesh part A is inside of closed mesh part B The version of <code>isInside</code> without collision check; it is user's responsibility to guarantee that the meshes don't collide  <br /></td></tr>
<tr class="separator:ga30d53ebf69ce150861f17e4695543778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3358455877a4f3ab26bb581338d86cd4" id="r_ga3358455877a4f3ab26bb581338d86cd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3358455877a4f3ab26bb581338d86cd4">MR::isNonIntersectingInside</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;a, FaceId partFace, const MeshPart &amp;b, const AffineXf3f *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga3358455877a4f3ab26bb581338d86cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks that arbitrary mesh A part (whole part is represented by one face <code>partFace</code>) is inside of closed mesh part B The version of <code>isInside</code> without collision check; it is user's responsibility to guarantee that the meshes don't collide  <br /></td></tr>
<tr class="separator:ga3358455877a4f3ab26bb581338d86cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7cfd40975f9648e9785f72d75ff92d" id="r_ga8f7cfd40975f9648e9785f72d75ff92d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8f7cfd40975f9648e9785f72d75ff92d">MR::operator==</a> (const <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &amp;a, const <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &amp;b)</td></tr>
<tr class="separator:ga8f7cfd40975f9648e9785f72d75ff92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d4ca955f1a62e15ebea578ffa83454" id="r_ga11d4ca955f1a62e15ebea578ffa83454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PreciseCollisionResult.html">PreciseCollisionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga11d4ca955f1a62e15ebea578ffa83454">MR::findCollidingEdgeTrisPrecise</a> (const MeshPart &amp;a, const MeshPart &amp;b, <a class="elRef" href="../namespaceMR.html#ab81d3ad87ff9cd57deee77336ddf83e1">ConvertToIntVector</a> conv, const AffineXf3f *rigidB2A=nullptr, bool anyIntersection=false)</td></tr>
<tr class="memdesc:ga11d4ca955f1a62e15ebea578ffa83454"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding edges from one mesh and triangle from another mesh  <br /></td></tr>
<tr class="separator:ga11d4ca955f1a62e15ebea578ffa83454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f22b9cff7188bb21cc3c7d72ec4a03" id="r_ga50f22b9cff7188bb21cc3c7d72ec4a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50f22b9cff7188bb21cc3c7d72ec4a03">MR::findSelfCollidingEdgeTrisPrecise</a> (const MeshPart &amp;mp, <a class="elRef" href="../namespaceMR.html#ab81d3ad87ff9cd57deee77336ddf83e1">ConvertToIntVector</a> conv, bool anyIntersection=false, const AffineXf3f *rigidB2A=nullptr, int aVertSizes=0)</td></tr>
<tr class="memdesc:ga50f22b9cff7188bb21cc3c7d72ec4a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding edges and triangle within one mesh  <br /></td></tr>
<tr class="separator:ga50f22b9cff7188bb21cc3c7d72ec4a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7d357b072699f62023d97ea1c81f45" id="r_ga8c7d357b072699f62023d97ea1c81f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c7d357b072699f62023d97ea1c81f45">MR::findCollidingEdgeTrisPrecise</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;a, const std::vector&lt; EdgeId &gt; &amp;edgesA, const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;b, const std::vector&lt; FaceId &gt; &amp;facesB, <a class="elRef" href="../namespaceMR.html#ab81d3ad87ff9cd57deee77336ddf83e1">ConvertToIntVector</a> conv, const AffineXf3f *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga8c7d357b072699f62023d97ea1c81f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all intersections between every given edge from A and given triangles from B  <br /></td></tr>
<tr class="separator:ga8c7d357b072699f62023d97ea1c81f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939afe34134c1d66c9ca5f19e33dc323" id="r_ga939afe34134c1d66c9ca5f19e33dc323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga939afe34134c1d66c9ca5f19e33dc323">MR::findCollidingEdgeTrisPrecise</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;a, const std::vector&lt; FaceId &gt; &amp;facesA, const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;b, const std::vector&lt; EdgeId &gt; &amp;edgesB, <a class="elRef" href="../namespaceMR.html#ab81d3ad87ff9cd57deee77336ddf83e1">ConvertToIntVector</a> conv, const AffineXf3f *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga939afe34134c1d66c9ca5f19e33dc323"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all intersections between every given triangle from A and given edge from B  <br /></td></tr>
<tr class="separator:ga939afe34134c1d66c9ca5f19e33dc323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125d7b99c7b4840e87a3470ef0c64b17" id="r_ga125d7b99c7b4840e87a3470ef0c64b17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1CoordinateConverters.html">CoordinateConverters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga125d7b99c7b4840e87a3470ef0c64b17">MR::getVectorConverters</a> (const MeshPart &amp;a, const MeshPart &amp;b, const AffineXf3f *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga125d7b99c7b4840e87a3470ef0c64b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates simple converters from Vector3f to Vector3i and back in mesh parts area range  <br /></td></tr>
<tr class="separator:ga125d7b99c7b4840e87a3470ef0c64b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb20234daa82631954c44c1676424e5f" id="r_gadb20234daa82631954c44c1676424e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadb20234daa82631954c44c1676424e5f">MR::processCloseTriangles</a> (const MeshPart &amp;mp, const <a class="elRef" href="../namespaceMR.html#ac3b4f93ff16dbb5975ce8dec6adc39cf">Triangle3f</a> &amp;t, float rangeSq, const <a class="el" href="#ga285ea5cd9fb638c90fec0099f526c057">TriangleCallback</a> &amp;call)</td></tr>
<tr class="separator:gadb20234daa82631954c44c1676424e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab849769857dbeadbea5f6bbfa749dfa0" id="r_gab849769857dbeadbea5f6bbfa749dfa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab849769857dbeadbea5f6bbfa749dfa0">MR::signedDistanceToMesh</a> (const MeshPart &amp;mp, const Vector3f &amp;p, const <a class="el" href="structMR_1_1SignedDistanceToMeshOptions.html">SignedDistanceToMeshOptions</a> &amp;op)</td></tr>
<tr class="separator:gab849769857dbeadbea5f6bbfa749dfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4bcd2a0d206e01852cba4f6e0c2a6b" id="r_ga4a4bcd2a0d206e01852cba4f6e0c2a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4a4bcd2a0d206e01852cba4f6e0c2a6b">MR::rayMeshIntersect</a> (const MeshPart &amp;meshPart, const Line3f &amp;line, float rayStart=0.0f, float rayEnd=FLT_MAX, const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; float &gt; *prec=nullptr, bool closestIntersect=true, const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;validFaces={})</td></tr>
<tr class="separator:ga4a4bcd2a0d206e01852cba4f6e0c2a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987d32cc52268b780f26e3733f7d0151" id="r_ga987d32cc52268b780f26e3733f7d0151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga987d32cc52268b780f26e3733f7d0151">MR::rayMeshIntersect</a> (const MeshPart &amp;meshPart, const Line3d &amp;line, double rayStart=0.0, double rayEnd=DBL_MAX, const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; double &gt; *prec=nullptr, bool closestIntersect=true, const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;validFaces={})</td></tr>
<tr class="separator:ga987d32cc52268b780f26e3733f7d0151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga041f851064ebbb5159343f98539fc045" id="r_ga041f851064ebbb5159343f98539fc045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga041f851064ebbb5159343f98539fc045">MR::multiRayMeshIntersect</a> (const MeshPart &amp;meshPart, const std::vector&lt; Vector3f &gt; &amp;origins, const std::vector&lt; Vector3f &gt; &amp;dirs, const <a class="el" href="structMR_1_1MultiRayMeshIntersectResult.html">MultiRayMeshIntersectResult</a> &amp;result, float rayStart=0.0f, float rayEnd=FLT_MAX, bool closestIntersect=true, const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;validFaces={})</td></tr>
<tr class="separator:ga041f851064ebbb5159343f98539fc045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ed53546770d894ff3f4ea75bd760afa" id="r_ga5ed53546770d894ff3f4ea75bd760afa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MultiMeshIntersectionResult.html">MultiMeshIntersectionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ed53546770d894ff3f4ea75bd760afa">MR::rayMultiMeshAnyIntersect</a> (const std::vector&lt; <a class="el" href="#ga9222ec2d954badb7ee5874321a084eb6">Line3fMesh</a> &gt; &amp;lineMeshes, float rayStart=0.0f, float rayEnd=FLT_MAX)</td></tr>
<tr class="separator:ga5ed53546770d894ff3f4ea75bd760afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca3917c935c4b071cac785463beaa5f2" id="r_gaca3917c935c4b071cac785463beaa5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MultiMeshIntersectionResult.html">MultiMeshIntersectionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaca3917c935c4b071cac785463beaa5f2">MR::rayMultiMeshAnyIntersect</a> (const std::vector&lt; <a class="el" href="#ga8ba650839d7806773bb542b986ac4283">Line3dMesh</a> &gt; &amp;lineMeshes, double rayStart=0.0, double rayEnd=DBL_MAX)</td></tr>
<tr class="memdesc:gaca3917c935c4b071cac785463beaa5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#rayMultiMeshAnyIntersectF">rayMultiMeshAnyIntersectF</a>, but use double precision.  <br /></td></tr>
<tr class="separator:gaca3917c935c4b071cac785463beaa5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac978c520f500c1e3dad2ddaff7a333f0" id="r_gac978c520f500c1e3dad2ddaff7a333f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac978c520f500c1e3dad2ddaff7a333f0">MR::rayMeshIntersectAll</a> (const MeshPart &amp;meshPart, const Line3f &amp;line, <a class="el" href="#gac20cf6ba073a7db1e2df313fb87d9517">MeshIntersectionCallback</a> callback, float rayStart=0.0f, float rayEnd=FLT_MAX, const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; float &gt; *prec=nullptr)</td></tr>
<tr class="separator:gac978c520f500c1e3dad2ddaff7a333f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f7fec7775a22ca743ad08d9b8ae3056" id="r_ga4f7fec7775a22ca743ad08d9b8ae3056"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4f7fec7775a22ca743ad08d9b8ae3056">MR::rayMeshIntersectAll</a> (const MeshPart &amp;meshPart, const Line3d &amp;line, <a class="el" href="#gac20cf6ba073a7db1e2df313fb87d9517">MeshIntersectionCallback</a> callback, double rayStart=0.0, double rayEnd=DBL_MAX, const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; double &gt; *prec=nullptr)</td></tr>
<tr class="memdesc:ga4f7fec7775a22ca743ad08d9b8ae3056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#rayMeshIntersectAllF">rayMeshIntersectAllF</a>, but use double precision.  <br /></td></tr>
<tr class="separator:ga4f7fec7775a22ca743ad08d9b8ae3056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2db465de4ef2df4f0f85fa142a612f" id="r_ga8b2db465de4ef2df4f0f85fa142a612f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8b2db465de4ef2df4f0f85fa142a612f">MR::planeMeshIntersect</a> (const MeshPart &amp;meshPart, const Plane3f &amp;plane, FaceBitSet *fs, UndirectedEdgeBitSet *ues, VertBitSet *vs, std::vector&lt; FaceId &gt; *fsVec=nullptr)</td></tr>
<tr class="separator:ga8b2db465de4ef2df4f0f85fa142a612f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b8be9888719bfd9c5944dc6293c902d" id="r_ga4b8be9888719bfd9c5944dc6293c902d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4b8be9888719bfd9c5944dc6293c902d">MR::xyPlaneMeshIntersect</a> (const MeshPart &amp;meshPart, float zLevel, FaceBitSet *fs, UndirectedEdgeBitSet *ues, VertBitSet *vs, std::vector&lt; FaceId &gt; *fsVec=nullptr)</td></tr>
<tr class="separator:ga4b8be9888719bfd9c5944dc6293c902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307aef2fadf0a7f062b4fab1daabe6e0" id="r_ga307aef2fadf0a7f062b4fab1daabe6e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshMeshDistanceResult.html">MeshMeshDistanceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga307aef2fadf0a7f062b4fab1daabe6e0">MR::findDistance</a> (const MeshPart &amp;a, const MeshPart &amp;b, const AffineXf3f *rigidB2A=nullptr, float upDistLimitSq=FLT_MAX)</td></tr>
<tr class="memdesc:ga307aef2fadf0a7f062b4fab1daabe6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes minimal distance between two meshes or two mesh regions  <br /></td></tr>
<tr class="separator:ga307aef2fadf0a7f062b4fab1daabe6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23c1ed1442e2de62ef49a64b7179d809" id="r_ga23c1ed1442e2de62ef49a64b7179d809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshMeshSignedDistanceResult.html">MeshMeshSignedDistanceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga23c1ed1442e2de62ef49a64b7179d809">MR::findSignedDistance</a> (const MeshPart &amp;a, const MeshPart &amp;b, const AffineXf3f *rigidB2A=nullptr, float upDistLimitSq=FLT_MAX)</td></tr>
<tr class="memdesc:ga23c1ed1442e2de62ef49a64b7179d809"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes minimal distance between two meshes  <br /></td></tr>
<tr class="separator:ga23c1ed1442e2de62ef49a64b7179d809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga375d9c9dcfb1fd7d9a254a73370d71ba" id="r_ga375d9c9dcfb1fd7d9a254a73370d71ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga375d9c9dcfb1fd7d9a254a73370d71ba">MR::findMaxDistanceSqOneWay</a> (const MeshPart &amp;a, const MeshPart &amp;b, const AffineXf3f *rigidB2A=nullptr, float maxDistanceSq=FLT_MAX)</td></tr>
<tr class="memdesc:ga375d9c9dcfb1fd7d9a254a73370d71ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum of the squared distances from each B-mesh vertex to A-mesh  <br /></td></tr>
<tr class="separator:ga375d9c9dcfb1fd7d9a254a73370d71ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3672072155e3f272d13a40ccd4645d02" id="r_ga3672072155e3f272d13a40ccd4645d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3672072155e3f272d13a40ccd4645d02">MR::findMaxDistanceSq</a> (const MeshPart &amp;a, const MeshPart &amp;b, const AffineXf3f *rigidB2A=nullptr, float maxDistanceSq=FLT_MAX)</td></tr>
<tr class="memdesc:ga3672072155e3f272d13a40ccd4645d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared Hausdorff distance between two meshes, that is the maximum of squared distances from each mesh vertex to the other mesh (in both directions)  <br /></td></tr>
<tr class="separator:ga3672072155e3f272d13a40ccd4645d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2574b6170fb044d2038e7fa9c0e2e4c1" id="r_ga2574b6170fb044d2038e7fa9c0e2e4c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshProjectionTransforms.html">MeshProjectionTransforms</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2574b6170fb044d2038e7fa9c0e2e4c1">MR::createProjectionTransforms</a> (AffineXf3f &amp;storageXf, const AffineXf3f *pointXf, const AffineXf3f *treeXf)</td></tr>
<tr class="memdesc:ga2574b6170fb044d2038e7fa9c0e2e4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates structure with simplified transforms for projection functions, with <code>rigidXfPoint</code> applied to point, and <code>nonRigidXfTree</code> applied to tree.  <br /></td></tr>
<tr class="separator:ga2574b6170fb044d2038e7fa9c0e2e4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa20d785f3f82fad58fb659bc0009563d" id="r_gaa20d785f3f82fad58fb659bc0009563d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa20d785f3f82fad58fb659bc0009563d">MR::findProjection</a> (const Vector3f &amp;pt, const MeshPart &amp;mp, float upDistLimitSq=FLT_MAX, const AffineXf3f *xf=nullptr, float loDistLimitSq=0, const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;validFaces={}, const std::function&lt; bool(const <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;)&gt; &amp;validProjections={})</td></tr>
<tr class="memdesc:gaa20d785f3f82fad58fb659bc0009563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on mesh (or its region) to given point  <br /></td></tr>
<tr class="separator:gaa20d785f3f82fad58fb659bc0009563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga415d472754b9db893c0765c00951faad" id="r_ga415d472754b9db893c0765c00951faad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga415d472754b9db893c0765c00951faad">MR::findProjectionSubtree</a> (const Vector3f &amp;pt, const MeshPart &amp;mp, const <a class="el" href="classMR_1_1AABBTree.html">AABBTree</a> &amp;tree, float upDistLimitSq=FLT_MAX, const AffineXf3f *xf=nullptr, float loDistLimitSq=0, const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;validFaces={}, const std::function&lt; bool(const <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;)&gt; &amp;validProjections={})</td></tr>
<tr class="memdesc:ga415d472754b9db893c0765c00951faad"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on mesh (or its region) to given point  <br /></td></tr>
<tr class="separator:ga415d472754b9db893c0765c00951faad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga565cdeaec23b7bd65c3776723571fac0" id="r_ga565cdeaec23b7bd65c3776723571fac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga565cdeaec23b7bd65c3776723571fac0">MR::findBoxedTrisInBall</a> (const MeshPart &amp;mp, Ball3f ball, const <a class="el" href="#ga4349e23b1c03bbeb120c81f3cbb8b615">FoundBoxedTriCallback</a> &amp;foundCallback)</td></tr>
<tr class="separator:ga565cdeaec23b7bd65c3776723571fac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354aa28c5105859923d024949d724b5f" id="r_ga354aa28c5105859923d024949d724b5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga354aa28c5105859923d024949d724b5f">MR::findTrisInBall</a> (const MeshPart &amp;mp, const Ball3f &amp;ball, const <a class="el" href="#ga3fa10deed3f5f765a28d62f2a9667c0f">FoundTriCallback</a> &amp;foundCallback, const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;validFaces={})</td></tr>
<tr class="separator:ga354aa28c5105859923d024949d724b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d0cb5151cae38d27130277c50301bc" id="r_ga44d0cb5151cae38d27130277c50301bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1SignedDistanceToMeshResult.html">SignedDistanceToMeshResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga44d0cb5151cae38d27130277c50301bc">MR::findSignedDistance</a> (const Vector3f &amp;pt, const MeshPart &amp;mp, float upDistLimitSq=FLT_MAX, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:ga44d0cb5151cae38d27130277c50301bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on mesh (or its region) to given point, and finds the distance with sign to it (positive - outside, negative - inside the mesh)  <br /></td></tr>
<tr class="separator:ga44d0cb5151cae38d27130277c50301bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f02307f8c1e25c4c6af4fa18f8f2335" id="r_ga4f02307f8c1e25c4c6af4fa18f8f2335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4f02307f8c1e25c4c6af4fa18f8f2335">MR::findPointsInBall</a> (const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;pointCloud, const Ball3f &amp;ball, const <a class="elRef" href="../namespaceMR.html#a421af22aea174a88968edea770000bbc">OnPointInBallFound</a> &amp;foundCallback, const AffineXf3f *xf=nullptr)</td></tr>
<tr class="separator:ga4f02307f8c1e25c4c6af4fa18f8f2335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0179ee38f25ea85a546273ad8523cc1" id="r_gaa0179ee38f25ea85a546273ad8523cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa0179ee38f25ea85a546273ad8523cc1">MR::findPointsInBall</a> (const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;pointCloud, const Ball3f &amp;ball, const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;foundCallback, const AffineXf3f *xf=nullptr)</td></tr>
<tr class="separator:gaa0179ee38f25ea85a546273ad8523cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf974a12892d479ea53f98fa7555dbcc5" id="r_gaf974a12892d479ea53f98fa7555dbcc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf974a12892d479ea53f98fa7555dbcc5">MR::findPointsInBall</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const Ball3f &amp;ball, const <a class="elRef" href="../namespaceMR.html#a421af22aea174a88968edea770000bbc">OnPointInBallFound</a> &amp;foundCallback, const AffineXf3f *xf=nullptr)</td></tr>
<tr class="separator:gaf974a12892d479ea53f98fa7555dbcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba782034adb2e6c3a4151210538caf0c" id="r_gaba782034adb2e6c3a4151210538caf0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaba782034adb2e6c3a4151210538caf0c">MR::findPointsInBall</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const Ball3f &amp;ball, const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;foundCallback, const AffineXf3f *xf=nullptr)</td></tr>
<tr class="separator:gaba782034adb2e6c3a4151210538caf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e0c1140b01d4055efb5e997a66e3678" id="r_ga1e0c1140b01d4055efb5e997a66e3678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1e0c1140b01d4055efb5e997a66e3678">MR::findPointsInBall</a> (const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;tree, Ball3f ball, const <a class="elRef" href="../namespaceMR.html#a421af22aea174a88968edea770000bbc">OnPointInBallFound</a> &amp;foundCallback, const AffineXf3f *xf=nullptr)</td></tr>
<tr class="separator:ga1e0c1140b01d4055efb5e997a66e3678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2d40a2f2b6c7ed32c4e278704bbd55a" id="r_gaa2d40a2f2b6c7ed32c4e278704bbd55a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa2d40a2f2b6c7ed32c4e278704bbd55a">MR::findPointsInBall</a> (const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;tree, const Ball3f &amp;ball, const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;foundCallback, const AffineXf3f *xf=nullptr)</td></tr>
<tr class="separator:gaa2d40a2f2b6c7ed32c4e278704bbd55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa4e215cb2613c2e801735695f22dd9" id="r_ga5fa4e215cb2613c2e801735695f22dd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5fa4e215cb2613c2e801735695f22dd9">MR::findPointsInBox</a> (const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;pointCloud, const Box3f &amp;box, const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;foundCallback, const AffineXf3f *xf=nullptr)</td></tr>
<tr class="separator:ga5fa4e215cb2613c2e801735695f22dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ebc24e7d3fa59c325ec9fed80e3f7c1" id="r_ga1ebc24e7d3fa59c325ec9fed80e3f7c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ebc24e7d3fa59c325ec9fed80e3f7c1">MR::findPointsInBox</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const Box3f &amp;box, const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;foundCallback, const AffineXf3f *xf=nullptr)</td></tr>
<tr class="separator:ga1ebc24e7d3fa59c325ec9fed80e3f7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga835e26690b8579246b5fe66eecd773ac" id="r_ga835e26690b8579246b5fe66eecd773ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga835e26690b8579246b5fe66eecd773ac">MR::findPointsInBox</a> (const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;tree, const Box3f &amp;box, const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;foundCallback, const AffineXf3f *xf=nullptr)</td></tr>
<tr class="separator:ga835e26690b8579246b5fe66eecd773ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a9ede35586c7db2c8ab59c42bcd6b7d" id="r_ga8a9ede35586c7db2c8ab59c42bcd6b7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PointsProjectionResult.html">PointsProjectionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8a9ede35586c7db2c8ab59c42bcd6b7d">MR::findProjectionOnPoints</a> (const Vector3f &amp;pt, const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;pc, float upDistLimitSq=FLT_MAX, const AffineXf3f *xf=nullptr, float loDistLimitSq=0, VertPredicate skipCb={})</td></tr>
<tr class="memdesc:ga8a9ede35586c7db2c8ab59c42bcd6b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on point cloud to given point  <br /></td></tr>
<tr class="separator:ga8a9ede35586c7db2c8ab59c42bcd6b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc2ddddc1d6fae40b8efc80cc28d123a" id="r_gabc2ddddc1d6fae40b8efc80cc28d123a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PointsProjectionResult.html">PointsProjectionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabc2ddddc1d6fae40b8efc80cc28d123a">MR::findProjectionOnPoints</a> (const Vector3f &amp;pt, const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;tree, float upDistLimitSq=FLT_MAX, const AffineXf3f *xf=nullptr, float loDistLimitSq=0, VertPredicate skipCb={})</td></tr>
<tr class="memdesc:gabc2ddddc1d6fae40b8efc80cc28d123a"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on <a class="el" href="classMR_1_1AABBTreePoints.html" title="bounding volume hierarchy for point cloud structure">AABBTreePoints</a> to given point  <br /></td></tr>
<tr class="separator:gabc2ddddc1d6fae40b8efc80cc28d123a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b2c2b50e8b1835a53ac746d5da87b54" id="r_ga5b2c2b50e8b1835a53ac746d5da87b54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b2c2b50e8b1835a53ac746d5da87b54">MR::findFewClosestPoints</a> (const Vector3f &amp;pt, const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;pc, <a class="el" href="classMR_1_1FewSmallest.html">FewSmallest</a>&lt; <a class="el" href="structMR_1_1PointsProjectionResult.html">PointsProjectionResult</a> &gt; &amp;res, float upDistLimitSq=FLT_MAX, const AffineXf3f *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:ga5b2c2b50e8b1835a53ac746d5da87b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a number of the closest points in the cloud (as configured in  <br /></td></tr>
<tr class="separator:ga5b2c2b50e8b1835a53ac746d5da87b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ccfb741cd4bcb092c8884f744051203" id="r_ga5ccfb741cd4bcb092c8884f744051203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="classMR_1_1Buffer.html">Buffer</a>&lt; VertId &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ccfb741cd4bcb092c8884f744051203">MR::findNClosestPointsPerPoint</a> (const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;pc, int numNei, const <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> &amp;progress={})</td></tr>
<tr class="memdesc:ga5ccfb741cd4bcb092c8884f744051203"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds given number of closest points (excluding itself) to each valid point in the cloud;  <br /></td></tr>
<tr class="separator:ga5ccfb741cd4bcb092c8884f744051203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994aaba24d39e18802b546f4fdab10cc" id="r_ga994aaba24d39e18802b546f4fdab10cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#ad75ce80ca78d38bd524b9c4ccd7a520d">VertPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga994aaba24d39e18802b546f4fdab10cc">MR::findTwoClosestPoints</a> (const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;pc, const <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> &amp;progress={})</td></tr>
<tr class="memdesc:ga994aaba24d39e18802b546f4fdab10cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds two closest points (first id &lt; second id) in whole point cloud  <br /></td></tr>
<tr class="separator:ga994aaba24d39e18802b546f4fdab10cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a3e18d2098f8ff33e67776a221e6fb" id="r_ga15a3e18d2098f8ff33e67776a221e6fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgePointPair.html">EdgePointPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga15a3e18d2098f8ff33e67776a221e6fb">MR::findCollidingEdgePairs</a> (const Polyline2 &amp;a, const Polyline2 &amp;b, const <a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *rigidB2A=nullptr, bool firstIntersectionOnly=false)</td></tr>
<tr class="memdesc:ga15a3e18d2098f8ff33e67776a221e6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding edges from two 2d polylines  <br /></td></tr>
<tr class="separator:ga15a3e18d2098f8ff33e67776a221e6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c8af10ceaf3059a77647d7b6f2ca8b" id="r_ga44c8af10ceaf3059a77647d7b6f2ca8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1UndirectedEdgeUndirectedEdge.html">UndirectedEdgeUndirectedEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga44c8af10ceaf3059a77647d7b6f2ca8b">MR::findCollidingEdges</a> (const Polyline2 &amp;a, const Polyline2 &amp;b, const <a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *rigidB2A=nullptr, bool firstIntersectionOnly=false)</td></tr>
<tr class="memdesc:ga44c8af10ceaf3059a77647d7b6f2ca8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding edges from two 2d polylines  <br /></td></tr>
<tr class="separator:ga44c8af10ceaf3059a77647d7b6f2ca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3404724c88f935957c8c3c8962ea3a" id="r_ga0f3404724c88f935957c8c3c8962ea3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::pair&lt; UndirectedEdgeBitSet, UndirectedEdgeBitSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f3404724c88f935957c8c3c8962ea3a">MR::findCollidingEdgesBitsets</a> (const Polyline2 &amp;a, const Polyline2 &amp;b, const <a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:ga0f3404724c88f935957c8c3c8962ea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds bitset per polyline with colliding edges  <br /></td></tr>
<tr class="separator:ga0f3404724c88f935957c8c3c8962ea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fca223a68dac564f66af0224c0ec3ec" id="r_ga4fca223a68dac564f66af0224c0ec3ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgePointPair.html">EdgePointPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4fca223a68dac564f66af0224c0ec3ec">MR::findSelfCollidingEdgePairs</a> (const Polyline2 &amp;polyline)</td></tr>
<tr class="memdesc:ga4fca223a68dac564f66af0224c0ec3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding edges from 2d polyline  <br /></td></tr>
<tr class="separator:ga4fca223a68dac564f66af0224c0ec3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89aed99c2cba4cd08e06d896b839841" id="r_gad89aed99c2cba4cd08e06d896b839841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1UndirectedEdgeUndirectedEdge.html">UndirectedEdgeUndirectedEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad89aed99c2cba4cd08e06d896b839841">MR::findSelfCollidingEdges</a> (const Polyline2 &amp;polyline)</td></tr>
<tr class="memdesc:gad89aed99c2cba4cd08e06d896b839841"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all pairs of colliding edges from 2d polyline  <br /></td></tr>
<tr class="separator:gad89aed99c2cba4cd08e06d896b839841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8658f18b6b0489c1dafa4903c64c0165" id="r_ga8658f18b6b0489c1dafa4903c64c0165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> UndirectedEdgeBitSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8658f18b6b0489c1dafa4903c64c0165">MR::findSelfCollidingEdgesBS</a> (const Polyline2 &amp;polyline)</td></tr>
<tr class="memdesc:ga8658f18b6b0489c1dafa4903c64c0165"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the union of all self-intersecting edges  <br /></td></tr>
<tr class="separator:ga8658f18b6b0489c1dafa4903c64c0165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d770560279dcdaa48764810b77c30d" id="r_gaa8d770560279dcdaa48764810b77c30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa8d770560279dcdaa48764810b77c30d">MR::isInside</a> (const Polyline2 &amp;a, const Polyline2 &amp;b, const <a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *rigidB2A=nullptr)</td></tr>
<tr class="memdesc:gaa8d770560279dcdaa48764810b77c30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks that arbitrary 2d polyline A is inside of closed 2d polyline B  <br /></td></tr>
<tr class="separator:gaa8d770560279dcdaa48764810b77c30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aba3040bbdbbafb7d8e38803b955524" id="r_ga2aba3040bbdbbafb7d8e38803b955524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2aba3040bbdbbafb7d8e38803b955524">MR::isPointInsidePolyline</a> (const Polyline2 &amp;polyline, const Vector2f &amp;point)</td></tr>
<tr class="memdesc:ga2aba3040bbdbbafb7d8e38803b955524"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect if given point is inside polyline, by counting ray intersections  <br /></td></tr>
<tr class="separator:ga2aba3040bbdbbafb7d8e38803b955524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7211a85409018fd8ee71495646faa3" id="r_ga7f7211a85409018fd8ee71495646faa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionResult2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f7211a85409018fd8ee71495646faa3">MR::findProjectionOnPolyline2</a> (const Vector2f &amp;pt, const Polyline2 &amp;polyline, float upDistLimitSq=FLT_MAX, <a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:ga7f7211a85409018fd8ee71495646faa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on polyline to given point  <br /></td></tr>
<tr class="separator:ga7f7211a85409018fd8ee71495646faa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e71a300face382a26ba8596d9b19820" id="r_ga5e71a300face382a26ba8596d9b19820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionResult3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5e71a300face382a26ba8596d9b19820">MR::findProjectionOnPolyline</a> (const Vector3f &amp;pt, const Polyline3 &amp;polyline, float upDistLimitSq=FLT_MAX, AffineXf3f *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:ga5e71a300face382a26ba8596d9b19820"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on polyline to given point  <br /></td></tr>
<tr class="separator:ga5e71a300face382a26ba8596d9b19820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga491ccc452b2d068da6ce82aaebcd5372" id="r_ga491ccc452b2d068da6ce82aaebcd5372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PolylineProjectionResult3Arg.html">PolylineProjectionResult3Arg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga491ccc452b2d068da6ce82aaebcd5372">MR::findMaxProjectionOnPolyline</a> (const VertCoords &amp;points, const Polyline3 &amp;polyline, const VertBitSet *pointsRegion=nullptr, AffineXf3f *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:ga491ccc452b2d068da6ce82aaebcd5372"><td class="mdescLeft">&#160;</td><td class="mdescRight">for each of points (pointsRegion) computes the closest point on polyline and returns the point for which maximum distance is reached,  <br /></td></tr>
<tr class="separator:ga491ccc452b2d068da6ce82aaebcd5372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa484a0628a7ac3858cd590589687141c" id="r_gaa484a0628a7ac3858cd590589687141c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionResult3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa484a0628a7ac3858cd590589687141c">MR::findProjectionOnPolyline</a> (const Line3f &amp;ln, const Polyline3 &amp;polyline, float upDistLimitSq=FLT_MAX, AffineXf3f *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:gaa484a0628a7ac3858cd590589687141c"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on polyline to given straight line  <br /></td></tr>
<tr class="separator:gaa484a0628a7ac3858cd590589687141c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ef419d4414bb6d0efa0c918b21bddf" id="r_gaf2ef419d4414bb6d0efa0c918b21bddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#acdd7942df456145c6efbf9d6524f3f88">Polyline2ProjectionWithOffsetResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf2ef419d4414bb6d0efa0c918b21bddf">MR::findProjectionOnPolyline2WithOffset</a> (const Vector2f &amp;pt, const Polyline2 &amp;polyline, const <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt; float, UndirectedEdgeId &gt; &amp;offsetPerEdge, float upDistLimit=FLT_MAX, <a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *xf=nullptr, float loDistLimit=0)</td></tr>
<tr class="memdesc:gaf2ef419d4414bb6d0efa0c918b21bddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on polyline to given point, respecting each edge offset  <br /></td></tr>
<tr class="separator:gaf2ef419d4414bb6d0efa0c918b21bddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834d7e50b54b1b8c511990fc9d14c09c" id="r_ga834d7e50b54b1b8c511990fc9d14c09c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionWithOffsetResult3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga834d7e50b54b1b8c511990fc9d14c09c">MR::findProjectionOnPolylineWithOffset</a> (const Vector3f &amp;pt, const Polyline3 &amp;polyline, const <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt; float, UndirectedEdgeId &gt; &amp;offsetPerEdge, float upDistLimit=FLT_MAX, AffineXf3f *xf=nullptr, float loDistLimit=0)</td></tr>
<tr class="memdesc:ga834d7e50b54b1b8c511990fc9d14c09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on polyline to given point, respecting each edge offset  <br /></td></tr>
<tr class="separator:ga834d7e50b54b1b8c511990fc9d14c09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce436376c8036ec99459d3ccea88788" id="r_ga5ce436376c8036ec99459d3ccea88788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ce436376c8036ec99459d3ccea88788">MR::findEdgesInBall</a> (const Polyline2 &amp;polyline, const Vector2f &amp;center, float radius, const <a class="el" href="#ga5e0d9af4be57927671a26f2c4588a515">FoundEdgeCallback2</a> &amp;foundCallback, <a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *xf=nullptr)</td></tr>
<tr class="memdesc:ga5ce436376c8036ec99459d3ccea88788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all edges of given polyline that cross or touch given ball (center, radius)  <br /></td></tr>
<tr class="separator:ga5ce436376c8036ec99459d3ccea88788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799578a1ff64417ca5aa5c72fa15bb2f" id="r_ga799578a1ff64417ca5aa5c72fa15bb2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga799578a1ff64417ca5aa5c72fa15bb2f">MR::findEdgesInBall</a> (const Polyline3 &amp;polyline, const Vector3f &amp;center, float radius, const <a class="el" href="#ga865abfe228b7d60d582d2c6ce24ffb19">FoundEdgeCallback3</a> &amp;foundCallback, AffineXf3f *xf=nullptr)</td></tr>
<tr class="memdesc:ga799578a1ff64417ca5aa5c72fa15bb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all edges of given polyline that cross or touch given ball (center, radius)  <br /></td></tr>
<tr class="separator:ga799578a1ff64417ca5aa5c72fa15bb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50911249a881bd7365929503c138d8fa" id="r_ga50911249a881bd7365929503c138d8fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50911249a881bd7365929503c138d8fa">MR::findMeshEdgesInBall</a> (const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const AABBTreePolyline3 &amp;tree, const Vector3f &amp;center, float radius, const <a class="el" href="#ga865abfe228b7d60d582d2c6ce24ffb19">FoundEdgeCallback3</a> &amp;foundCallback, AffineXf3f *xf=nullptr)</td></tr>
<tr class="memdesc:ga50911249a881bd7365929503c138d8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all edges of given mesh edges (specified by the tree) that cross or touch given ball (center, radius)  <br /></td></tr>
<tr class="separator:ga50911249a881bd7365929503c138d8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c37b9a7a04aa567390955a50891b57" id="r_ga64c37b9a7a04aa567390955a50891b57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionResult3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga64c37b9a7a04aa567390955a50891b57">MR::findProjectionOnMeshEdges</a> (const Vector3f &amp;pt, const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const AABBTreePolyline3 &amp;tree, float upDistLimitSq=FLT_MAX, AffineXf3f *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:ga64c37b9a7a04aa567390955a50891b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on the mesh edges (specified by the tree) to given point  <br /></td></tr>
<tr class="separator:ga64c37b9a7a04aa567390955a50891b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdf7712b3c2bc175e4b09aae138aa40" id="r_gaccdf7712b3c2bc175e4b09aae138aa40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionResult3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaccdf7712b3c2bc175e4b09aae138aa40">MR::findProjectionOnMeshEdges</a> (const Line3f &amp;ln, const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;mesh, const AABBTreePolyline3 &amp;tree, float upDistLimitSq=FLT_MAX, AffineXf3f *xf=nullptr, float loDistLimitSq=0)</td></tr>
<tr class="memdesc:gaccdf7712b3c2bc175e4b09aae138aa40"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the closest point on the mesh edges (specified by the tree) to given straight line  <br /></td></tr>
<tr class="separator:gaccdf7712b3c2bc175e4b09aae138aa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5e3f58e5a000086f4df8523da65c9b4f" id="r_ga5e3f58e5a000086f4df8523da65c9b4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5e3f58e5a000086f4df8523da65c9b4f">MR::IntersectionPrecomputes&lt; T &gt;::invDir</a></td></tr>
<tr class="separator:ga5e3f58e5a000086f4df8523da65c9b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffa5bcb7a516c4dda421ace86e2597c2" id="r_gaffa5bcb7a516c4dda421ace86e2597c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaffa5bcb7a516c4dda421ace86e2597c2">MR::IntersectionPrecomputes&lt; T &gt;::maxDimIdxZ</a> = 2</td></tr>
<tr class="separator:gaffa5bcb7a516c4dda421ace86e2597c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59240ce19dcf5b27221a347b22086fcb" id="r_ga59240ce19dcf5b27221a347b22086fcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga59240ce19dcf5b27221a347b22086fcb">MR::IntersectionPrecomputes&lt; T &gt;::idxX</a> = 0</td></tr>
<tr class="separator:ga59240ce19dcf5b27221a347b22086fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e89bb11cf7c4693e1c8839963994a08" id="r_ga1e89bb11cf7c4693e1c8839963994a08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1e89bb11cf7c4693e1c8839963994a08">MR::IntersectionPrecomputes&lt; T &gt;::idxY</a> = 1</td></tr>
<tr class="separator:ga1e89bb11cf7c4693e1c8839963994a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28372a635ba67b43220bc9067be6560d" id="r_ga28372a635ba67b43220bc9067be6560d"><td class="memItemLeft" align="right" valign="top">Vector3i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga28372a635ba67b43220bc9067be6560d">MR::IntersectionPrecomputes&lt; T &gt;::sign</a></td></tr>
<tr class="memdesc:ga28372a635ba67b43220bc9067be6560d"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores signs of direction vector;  <br /></td></tr>
<tr class="separator:ga28372a635ba67b43220bc9067be6560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21465bc7d67177777744f39ac171940c" id="r_ga21465bc7d67177777744f39ac171940c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga21465bc7d67177777744f39ac171940c">MR::IntersectionPrecomputes&lt; T &gt;::Sx</a></td></tr>
<tr class="memdesc:ga21465bc7d67177777744f39ac171940c"><td class="mdescLeft">&#160;</td><td class="mdescRight">precomputed factors  <br /></td></tr>
<tr class="separator:ga21465bc7d67177777744f39ac171940c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf95502c89221bba3187782d4ed18199b" id="r_gaf95502c89221bba3187782d4ed18199b"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf95502c89221bba3187782d4ed18199b">MR::IntersectionPrecomputes&lt; T &gt;::Sy</a></td></tr>
<tr class="separator:gaf95502c89221bba3187782d4ed18199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6159c869b0afc38ccf26091c1681194a" id="r_ga6159c869b0afc38ccf26091c1681194a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6159c869b0afc38ccf26091c1681194a">MR::IntersectionPrecomputes&lt; T &gt;::Sz</a></td></tr>
<tr class="separator:ga6159c869b0afc38ccf26091c1681194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This chapter represents documentation about AABB Tree. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga01c75e3c26967a90edbe075a77cb2ca9" name="ga01c75e3c26967a90edbe075a77cb2ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01c75e3c26967a90edbe075a77cb2ca9">&#9670;&#160;</a></span>AABBTreeNodeVec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga01c75e3c26967a90edbe075a77cb2ca9">MR::AABBTreeNodeVec</a> = <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt;<a class="el" href="structMR_1_1AABBTreeNode.html">AABBTreeNode</a>&lt;T&gt;, NodeId&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2d9f9e10f5365b971c9f7300264be632" name="ga2d9f9e10f5365b971c9f7300264be632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d9f9e10f5365b971c9f7300264be632">&#9670;&#160;</a></span>FaceTreeTraits3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga2d9f9e10f5365b971c9f7300264be632">MR::FaceTreeTraits3</a> = <a class="el" href="structMR_1_1AABBTreeTraits.html">AABBTreeTraits</a>&lt;<a class="elRef" href="../namespaceMR.html#a7a4a96848eb4b1524be699a7adcd8017">FaceTag</a>, Box3f&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4349e23b1c03bbeb120c81f3cbb8b615" name="ga4349e23b1c03bbeb120c81f3cbb8b615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4349e23b1c03bbeb120c81f3cbb8b615">&#9670;&#160;</a></span>FoundBoxedTriCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga4349e23b1c03bbeb120c81f3cbb8b615">MR::FoundBoxedTriCallback</a> = std::function&lt;<a class="elRef" href="../namespaceMR.html#ae9fc4543eb3302ae33b7843707485149">Processing</a>( FaceId found, Ball3f &amp; ball )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this callback is invoked on every triangle with bounding box at least partially in the ball (the triangle itself can be fully out of ball), and allows changing (shrinking only) the ball </p>

</div>
</div>
<a id="gac2b944209dd41b786a30b1d537639470" name="gac2b944209dd41b786a30b1d537639470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2b944209dd41b786a30b1d537639470">&#9670;&#160;</a></span>FoundEdgeCallback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gac2b944209dd41b786a30b1d537639470">MR::FoundEdgeCallback</a> = std::function&lt;void( UndirectedEdgeId, const V&amp; closestPt, float distSq )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5e0d9af4be57927671a26f2c4588a515" name="ga5e0d9af4be57927671a26f2c4588a515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e0d9af4be57927671a26f2c4588a515">&#9670;&#160;</a></span>FoundEdgeCallback2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga5e0d9af4be57927671a26f2c4588a515">MR::FoundEdgeCallback2</a> = <a class="el" href="#gac2b944209dd41b786a30b1d537639470">FoundEdgeCallback</a>&lt;Vector2f&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga865abfe228b7d60d582d2c6ce24ffb19" name="ga865abfe228b7d60d582d2c6ce24ffb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga865abfe228b7d60d582d2c6ce24ffb19">&#9670;&#160;</a></span>FoundEdgeCallback3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga865abfe228b7d60d582d2c6ce24ffb19">MR::FoundEdgeCallback3</a> = <a class="el" href="#gac2b944209dd41b786a30b1d537639470">FoundEdgeCallback</a>&lt;Vector3f&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3fa10deed3f5f765a28d62f2a9667c0f" name="ga3fa10deed3f5f765a28d62f2a9667c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fa10deed3f5f765a28d62f2a9667c0f">&#9670;&#160;</a></span>FoundTriCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga3fa10deed3f5f765a28d62f2a9667c0f">MR::FoundTriCallback</a> = std::function&lt;<a class="elRef" href="../namespaceMR.html#ae9fc4543eb3302ae33b7843707485149">Processing</a>( const <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp; found, Ball3f &amp; ball )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this callback is invoked on every triangle at least partially in the ball, and allows changing (shrinking only) the ball </p>

</div>
</div>
<a id="ga8ba650839d7806773bb542b986ac4283" name="ga8ba650839d7806773bb542b986ac4283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ba650839d7806773bb542b986ac4283">&#9670;&#160;</a></span>Line3dMesh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga8ba650839d7806773bb542b986ac4283">MR::Line3dMesh</a> = <a class="el" href="structMR_1_1Line3Mesh.html">Line3Mesh</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9222ec2d954badb7ee5874321a084eb6" name="ga9222ec2d954badb7ee5874321a084eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9222ec2d954badb7ee5874321a084eb6">&#9670;&#160;</a></span>Line3fMesh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga9222ec2d954badb7ee5874321a084eb6">MR::Line3fMesh</a> = <a class="el" href="structMR_1_1Line3Mesh.html">Line3Mesh</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga876e325460f0c5460c1e453324ca329c" name="ga876e325460f0c5460c1e453324ca329c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga876e325460f0c5460c1e453324ca329c">&#9670;&#160;</a></span>LineTreeTraits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga876e325460f0c5460c1e453324ca329c">MR::LineTreeTraits</a> = <a class="el" href="structMR_1_1AABBTreeTraits.html">AABBTreeTraits</a>&lt;<a class="elRef" href="../namespaceMR.html#a1bbe6aa7d7136f740286af86f591c19b">UndirectedEdgeTag</a>, <a class="el" href="structMR_1_1Box.html">Box</a>&lt;V&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga346d2e7774495e3e4ca05a2325f11aaf" name="ga346d2e7774495e3e4ca05a2325f11aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga346d2e7774495e3e4ca05a2325f11aaf">&#9670;&#160;</a></span>LineTreeTraits2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga346d2e7774495e3e4ca05a2325f11aaf">MR::LineTreeTraits2</a> = <a class="el" href="#ga876e325460f0c5460c1e453324ca329c">LineTreeTraits</a>&lt;Vector2f&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gacf6e57b5e87718397acc1762969ad77a" name="gacf6e57b5e87718397acc1762969ad77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf6e57b5e87718397acc1762969ad77a">&#9670;&#160;</a></span>LineTreeTraits3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gacf6e57b5e87718397acc1762969ad77a">MR::LineTreeTraits3</a> = <a class="el" href="#ga876e325460f0c5460c1e453324ca329c">LineTreeTraits</a>&lt;Vector3f&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac20cf6ba073a7db1e2df313fb87d9517" name="gac20cf6ba073a7db1e2df313fb87d9517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac20cf6ba073a7db1e2df313fb87d9517">&#9670;&#160;</a></span>MeshIntersectionCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gac20cf6ba073a7db1e2df313fb87d9517">MR::MeshIntersectionCallback</a> = std::function&lt;bool(const <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this callback is envoked for each encountered ray-mesh intersection; if it returns false, then the search immediately terminates </p>

</div>
</div>
<a id="ga285ea5cd9fb638c90fec0099f526c057" name="ga285ea5cd9fb638c90fec0099f526c057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga285ea5cd9fb638c90fec0099f526c057">&#9670;&#160;</a></span>TriangleCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga285ea5cd9fb638c90fec0099f526c057">MR::TriangleCallback</a> = std::function&lt;<a class="el" href="#ga3dd2fd9fcc06b6502d22a9ea3eb63e47">ProcessOneResult</a>( const Vector3f &amp; p, FaceId f, const Vector3f &amp; q, float distSq )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this callback is invoked for every triangle in range, where </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>closest point on original triangle </td></tr>
    <tr><td class="paramname">f</td><td>triangle id in question </td></tr>
    <tr><td class="paramname">q</td><td>closest point on f-triangle </td></tr>
    <tr><td class="paramname">distSq</td><td>squared distance in between p and q </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether to continue or to stop processing other triangles </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3dd2fd9fcc06b6502d22a9ea3eb63e47" name="ga3dd2fd9fcc06b6502d22a9ea3eb63e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd2fd9fcc06b6502d22a9ea3eb63e47">&#9670;&#160;</a></span>ProcessOneResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ga3dd2fd9fcc06b6502d22a9ea3eb63e47">MR::ProcessOneResult</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3dd2fd9fcc06b6502d22a9ea3eb63e47a38e59feb928e37292c8ee0a50f447612" name="gga3dd2fd9fcc06b6502d22a9ea3eb63e47a38e59feb928e37292c8ee0a50f447612"></a>StopProcessing&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3dd2fd9fcc06b6502d22a9ea3eb63e47aab6bb60f51b25ae0f7ec450173e3348e" name="gga3dd2fd9fcc06b6502d22a9ea3eb63e47aab6bb60f51b25ae0f7ec450173e3348e"></a>ContinueProcessing&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2574b6170fb044d2038e7fa9c0e2e4c1" name="ga2574b6170fb044d2038e7fa9c0e2e4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2574b6170fb044d2038e7fa9c0e2e4c1">&#9670;&#160;</a></span>createProjectionTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshProjectionTransforms.html">MeshProjectionTransforms</a> MR::createProjectionTransforms </td>
          <td>(</td>
          <td class="paramtype">AffineXf3f &amp;</td>          <td class="paramname"><span class="paramname"><em>storageXf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>pointXf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>treeXf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates structure with simplified transforms for projection functions, with <code>rigidXfPoint</code> applied to point, and <code>nonRigidXfTree</code> applied to tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storageXf</td><td>this argument will hold modified transfrom</td></tr>
    <tr><td class="paramname">pointXf</td><td>transform for points to be projected</td></tr>
    <tr><td class="paramname">treeXf</td><td>transform for tree's boxes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>structure with simplified transforms</dd></dl>

</div>
</div>
<a id="ga565cdeaec23b7bd65c3776723571fac0" name="ga565cdeaec23b7bd65c3776723571fac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga565cdeaec23b7bd65c3776723571fac0">&#9670;&#160;</a></span>findBoxedTrisInBall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findBoxedTrisInBall </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ball3f</td>          <td class="paramname"><span class="paramname"><em>ball</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ga4349e23b1c03bbeb120c81f3cbb8b615">FoundBoxedTriCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enumerates all triangles with bounding boxes at least partially in the ball (the triangles themselves can be fully out of ball) until callback returns Stop; the ball during enumeration can shrink (new ball is always within the previous one) but never expand </p>

</div>
</div>
<a id="ga15a3e18d2098f8ff33e67776a221e6fb" name="ga15a3e18d2098f8ff33e67776a221e6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15a3e18d2098f8ff33e67776a221e6fb">&#9670;&#160;</a></span>findCollidingEdgePairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgePointPair.html">EdgePointPair</a> &gt; MR::findCollidingEdgePairs </td>
          <td>(</td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>firstIntersectionOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding edges from two 2d polylines </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-polyline space to A polyline space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">firstIntersectionOnly</td><td>if true then the function returns at most one pair of intersecting edges and returns faster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44c8af10ceaf3059a77647d7b6f2ca8b" name="ga44c8af10ceaf3059a77647d7b6f2ca8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44c8af10ceaf3059a77647d7b6f2ca8b">&#9670;&#160;</a></span>findCollidingEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1UndirectedEdgeUndirectedEdge.html">UndirectedEdgeUndirectedEdge</a> &gt; MR::findCollidingEdges </td>
          <td>(</td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>firstIntersectionOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding edges from two 2d polylines </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-polyline space to A polyline space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">firstIntersectionOnly</td><td>if true then the function returns at most one pair of intersecting edges and returns faster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f3404724c88f935957c8c3c8962ea3a" name="ga0f3404724c88f935957c8c3c8962ea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f3404724c88f935957c8c3c8962ea3a">&#9670;&#160;</a></span>findCollidingEdgesBitsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::pair&lt; UndirectedEdgeBitSet, UndirectedEdgeBitSet &gt; MR::findCollidingEdgesBitsets </td>
          <td>(</td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds bitset per polyline with colliding edges </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-polyline space to A polyline space, nullptr considered as identity transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c7d357b072699f62023d97ea1c81f45" name="ga8c7d357b072699f62023d97ea1c81f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c7d357b072699f62023d97ea1c81f45">&#9670;&#160;</a></span>findCollidingEdgeTrisPrecise() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &gt; MR::findCollidingEdgeTrisPrecise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; EdgeId &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edgesA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; FaceId &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>facesB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#ab81d3ad87ff9cd57deee77336ddf83e1">ConvertToIntVector</a></td>          <td class="paramname"><span class="paramname"><em>conv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all intersections between every given edge from A and given triangles from B </p>

</div>
</div>
<a id="ga939afe34134c1d66c9ca5f19e33dc323" name="ga939afe34134c1d66c9ca5f19e33dc323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga939afe34134c1d66c9ca5f19e33dc323">&#9670;&#160;</a></span>findCollidingEdgeTrisPrecise() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &gt; MR::findCollidingEdgeTrisPrecise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; FaceId &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>facesA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; EdgeId &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edgesB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#ab81d3ad87ff9cd57deee77336ddf83e1">ConvertToIntVector</a></td>          <td class="paramname"><span class="paramname"><em>conv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all intersections between every given triangle from A and given edge from B </p>

</div>
</div>
<a id="ga11d4ca955f1a62e15ebea578ffa83454" name="ga11d4ca955f1a62e15ebea578ffa83454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11d4ca955f1a62e15ebea578ffa83454">&#9670;&#160;</a></span>findCollidingEdgeTrisPrecise() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PreciseCollisionResult.html">PreciseCollisionResult</a> MR::findCollidingEdgeTrisPrecise </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#ab81d3ad87ff9cd57deee77336ddf83e1">ConvertToIntVector</a></td>          <td class="paramname"><span class="paramname"><em>conv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>anyIntersection</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding edges from one mesh and triangle from another mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">anyIntersection</td><td>if true then the function returns as fast as it finds any intersection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47e983a2ba53dbe6d49313488f3cae23" name="ga47e983a2ba53dbe6d49313488f3cae23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47e983a2ba53dbe6d49313488f3cae23">&#9670;&#160;</a></span>findCollidingTriangleBitsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::pair&lt; FaceBitSet, FaceBitSet &gt; MR::findCollidingTriangleBitsets </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the same as <a class="el" href="#gaaeb209f0c917451a03debbf058fc39e6">findCollidingTriangles</a>, but returns one bite set per mesh with colliding triangles </p>

</div>
</div>
<a id="gaaeb209f0c917451a03debbf058fc39e6" name="gaaeb209f0c917451a03debbf058fc39e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeb209f0c917451a03debbf058fc39e6">&#9670;&#160;</a></span>findCollidingTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1FaceFace.html">FaceFace</a> &gt; MR::findCollidingTriangles </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>firstIntersectionOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds all pairs of colliding triangles from two meshes or two mesh regions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">firstIntersectionOnly</td><td>if true then the function returns at most one pair of intersecting triangles and returns faster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga650448329cde9ee6b4e27760630a09a1" name="ga650448329cde9ee6b4e27760630a09a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga650448329cde9ee6b4e27760630a09a1">&#9670;&#160;</a></span>findDirMax() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId MR::findDirMax </td>
          <td>(</td>
          <td class="paramtype">const Vector2f &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span><span class="paramdefsep"> = </span><span class="paramdefval">UseAABBTree::Yes</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>finds the vertex in the polyline having the largest projection on given direction, optionally uses aabb-tree inside for faster computation </p>

</div>
</div>
<a id="ga025c593a83827d6bf51e5df0acd27db5" name="ga025c593a83827d6bf51e5df0acd27db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga025c593a83827d6bf51e5df0acd27db5">&#9670;&#160;</a></span>findDirMax() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId MR::findDirMax </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>finds the point in the tree having the largest projection on given direction </p>

</div>
</div>
<a id="ga68e6755511856f1d2c49843267a81d4c" name="ga68e6755511856f1d2c49843267a81d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68e6755511856f1d2c49843267a81d4c">&#9670;&#160;</a></span>findDirMax() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId MR::findDirMax </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span><span class="paramdefsep"> = </span><span class="paramdefval">UseAABBTree::Yes</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>finds the vertex in the mesh part having the largest projection on given direction, optionally uses aabb-tree inside for faster computation </p>

</div>
</div>
<a id="gaf49d29fe114a45e7ba44769ed23e07a7" name="gaf49d29fe114a45e7ba44769ed23e07a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf49d29fe114a45e7ba44769ed23e07a7">&#9670;&#160;</a></span>findDirMax() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId MR::findDirMax </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span><span class="paramdefsep"> = </span><span class="paramdefval">UseAABBTree::Yes</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>finds the vertex in the mesh part having the largest projection on given direction, optionally uses aabb-tree inside for faster computation </p>

</div>
</div>
<a id="gaa1b086afbde5a06209437e0bf56bc6d9" name="gaa1b086afbde5a06209437e0bf56bc6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1b086afbde5a06209437e0bf56bc6d9">&#9670;&#160;</a></span>findDirMax() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId MR::findDirMax </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshVertPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span><span class="paramdefsep"> = </span><span class="paramdefval">UseAABBTree::Yes</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>finds the vertex in the mesh part having the largest projection on given direction, optionally uses aabb-points-tree inside for faster computation </p>

</div>
</div>
<a id="ga66e2ad7a22a0bdbd4e16907bd521c654" name="ga66e2ad7a22a0bdbd4e16907bd521c654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66e2ad7a22a0bdbd4e16907bd521c654">&#9670;&#160;</a></span>findDirMax() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId MR::findDirMax </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cloud</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertBitSet *</td>          <td class="paramname"><span class="paramname"><em>region</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span><span class="paramdefsep"> = </span><span class="paramdefval">UseAABBTree::Yes</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>finds the point in the cloud having the largest projection on given direction, optionally uses aabb-tree inside for faster computation </p>

</div>
</div>
<a id="gaa5ff2fe386af48055096b3eb89f158b6" name="gaa5ff2fe386af48055096b3eb89f158b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5ff2fe386af48055096b3eb89f158b6">&#9670;&#160;</a></span>findDirMax() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> VertId MR::findDirMax </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline3 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#afb67fe49bcb6006882e7b08e51b2eeff">UseAABBTree</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span><span class="paramdefsep"> = </span><span class="paramdefval">UseAABBTree::Yes</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>finds the vertex in the polyline having the largest projection on given direction, optionally uses aabb-tree inside for faster computation </p>

</div>
</div>
<a id="ga307aef2fadf0a7f062b4fab1daabe6e0" name="ga307aef2fadf0a7f062b4fab1daabe6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga307aef2fadf0a7f062b4fab1daabe6e0">&#9670;&#160;</a></span>findDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshMeshDistanceResult.html">MeshMeshDistanceResult</a> MR::findDistance </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes minimal distance between two meshes or two mesh regions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exists returning upDistLimitSq and no valid points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ce436376c8036ec99459d3ccea88788" name="ga5ce436376c8036ec99459d3ccea88788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ce436376c8036ec99459d3ccea88788">&#9670;&#160;</a></span>findEdgesInBall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findEdgesInBall </td>
          <td>(</td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2f &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ga5e0d9af4be57927671a26f2c4588a515">FoundEdgeCallback2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all edges of given polyline that cross or touch given ball (center, radius) </p>

</div>
</div>
<a id="ga799578a1ff64417ca5aa5c72fa15bb2f" name="ga799578a1ff64417ca5aa5c72fa15bb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga799578a1ff64417ca5aa5c72fa15bb2f">&#9670;&#160;</a></span>findEdgesInBall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findEdgesInBall </td>
          <td>(</td>
          <td class="paramtype">const Polyline3 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ga865abfe228b7d60d582d2c6ce24ffb19">FoundEdgeCallback3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all edges of given polyline that cross or touch given ball (center, radius) </p>

</div>
</div>
<a id="ga5b2c2b50e8b1835a53ac746d5da87b54" name="ga5b2c2b50e8b1835a53ac746d5da87b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b2c2b50e8b1835a53ac746d5da87b54">&#9670;&#160;</a></span>findFewClosestPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findFewClosestPoints </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMR_1_1FewSmallest.html">FewSmallest</a>&lt; <a class="el" href="structMR_1_1PointsProjectionResult.html">PointsProjectionResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a number of the closest points in the cloud (as configured in </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res)</td><td>to given point </td></tr>
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, points with larger distance than it will not be returned </td></tr>
    <tr><td class="paramname">xf</td><td>pointcloud-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, the algorithm can return given number of points within this distance even skipping closer ones </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3672072155e3f272d13a40ccd4645d02" name="ga3672072155e3f272d13a40ccd4645d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3672072155e3f272d13a40ccd4645d02">&#9670;&#160;</a></span>findMaxDistanceSq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::findMaxDistanceSq </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maxDistanceSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the squared Hausdorff distance between two meshes, that is the maximum of squared distances from each mesh vertex to the other mesh (in both directions) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">maxDistanceSq</td><td>upper limit on the positive distance in question, if the real distance is larger than the function exists returning maxDistanceSq </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga375d9c9dcfb1fd7d9a254a73370d71ba" name="ga375d9c9dcfb1fd7d9a254a73370d71ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga375d9c9dcfb1fd7d9a254a73370d71ba">&#9670;&#160;</a></span>findMaxDistanceSqOneWay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> float MR::findMaxDistanceSqOneWay </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maxDistanceSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the maximum of the squared distances from each B-mesh vertex to A-mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">maxDistanceSq</td><td>upper limit on the positive distance in question, if the real distance is larger than the function exists returning maxDistanceSq </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga491ccc452b2d068da6ce82aaebcd5372" name="ga491ccc452b2d068da6ce82aaebcd5372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga491ccc452b2d068da6ce82aaebcd5372">&#9670;&#160;</a></span>findMaxProjectionOnPolyline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PolylineProjectionResult3Arg.html">PolylineProjectionResult3Arg</a> MR::findMaxProjectionOnPolyline </td>
          <td>(</td>
          <td class="paramtype">const VertCoords &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline3 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertBitSet *</td>          <td class="paramname"><span class="paramname"><em>pointsRegion</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for each of points (pointsRegion) computes the closest point on polyline and returns the point for which maximum distance is reached, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga562052fddd56327be07ffe8c0cc7f7af" name="ga562052fddd56327be07ffe8c0cc7f7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga562052fddd56327be07ffe8c0cc7f7af">&#9670;&#160;</a></span>findMaxVectorDim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MR::findMaxVectorDim </td>
          <td>(</td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>dimX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>dimY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Vector2.html">Vector2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds index of maximum axis and stores it into dimY </p>
<p><a href="http://jcgt.org/published/0002/01/05/paper.pdf">http://jcgt.org/published/0002/01/05/paper.pdf</a> Example input: dir = (1,-2). Result: dimY = 1, dimX = 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dimX</td><td>index of minimum axis </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dimY</td><td>index of maximum axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fcb33a674ea8b57ac858e40d42e26e3" name="ga7fcb33a674ea8b57ac858e40d42e26e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcb33a674ea8b57ac858e40d42e26e3">&#9670;&#160;</a></span>findMaxVectorDim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MR::findMaxVectorDim </td>
          <td>(</td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>dimX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>dimY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>dimZ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds index of maximum axis and stores it into dimZ </p>
<p><a href="http://jcgt.org/published/0002/01/05/paper.pdf">http://jcgt.org/published/0002/01/05/paper.pdf</a> Example input: dir = (1,1,-2). Result: dimZ = 2, dimX = 1, dimY = 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dimX</td><td>are filled by right-hand rule from dimZ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dimY</td><td>are filled by right-hand rule from dimZ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dimZ</td><td>index of maximum axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50911249a881bd7365929503c138d8fa" name="ga50911249a881bd7365929503c138d8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50911249a881bd7365929503c138d8fa">&#9670;&#160;</a></span>findMeshEdgesInBall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findMeshEdgesInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AABBTreePolyline3 &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ga865abfe228b7d60d582d2c6ce24ffb19">FoundEdgeCallback3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all edges of given mesh edges (specified by the tree) that cross or touch given ball (center, radius) </p>

</div>
</div>
<a id="ga5ccfb741cd4bcb092c8884f744051203" name="ga5ccfb741cd4bcb092c8884f744051203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ccfb741cd4bcb092c8884f744051203">&#9670;&#160;</a></span>findNClosestPointsPerPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="classMR_1_1Buffer.html">Buffer</a>&lt; VertId &gt; MR::findNClosestPointsPerPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numNei</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>progress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds given number of closest points (excluding itself) to each valid point in the cloud; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numNei</td><td>the number of closest points to find for each point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffer where for every valid point with index <code>i</code> its neighbours are stored at indices [i*numNei; (i+1)*numNei) </dd></dl>

</div>
</div>
<a id="ga1e0c1140b01d4055efb5e997a66e3678" name="ga1e0c1140b01d4055efb5e997a66e3678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e0c1140b01d4055efb5e997a66e3678">&#9670;&#160;</a></span>findPointsInBall() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ball3f</td>          <td class="paramname"><span class="paramname"><em>ball</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a421af22aea174a88968edea770000bbc">OnPointInBallFound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all points in tree that are inside or on the surface of given ball until callback returns Stop; the ball can shrink (new ball is always within the previous one) during the search but never expand</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2d40a2f2b6c7ed32c4e278704bbd55a" name="gaa2d40a2f2b6c7ed32c4e278704bbd55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2d40a2f2b6c7ed32c4e278704bbd55a">&#9670;&#160;</a></span>findPointsInBall() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ball3f &amp;</td>          <td class="paramname"><span class="paramname"><em>ball</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all points in tree that are inside or on the surface of given ball</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba782034adb2e6c3a4151210538caf0c" name="gaba782034adb2e6c3a4151210538caf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba782034adb2e6c3a4151210538caf0c">&#9670;&#160;</a></span>findPointsInBall() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ball3f &amp;</td>          <td class="paramname"><span class="paramname"><em>ball</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all valid vertices of the mesh that are inside or on the surface of given ball</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf974a12892d479ea53f98fa7555dbcc5" name="gaf974a12892d479ea53f98fa7555dbcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf974a12892d479ea53f98fa7555dbcc5">&#9670;&#160;</a></span>findPointsInBall() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ball3f &amp;</td>          <td class="paramname"><span class="paramname"><em>ball</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a421af22aea174a88968edea770000bbc">OnPointInBallFound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all valid vertices of the mesh that are inside or on the surface of given ball until callback returns Stop; the ball can shrink (new ball is always within the previous one) during the search but never expand</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa0179ee38f25ea85a546273ad8523cc1" name="gaa0179ee38f25ea85a546273ad8523cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0179ee38f25ea85a546273ad8523cc1">&#9670;&#160;</a></span>findPointsInBall() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pointCloud</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ball3f &amp;</td>          <td class="paramname"><span class="paramname"><em>ball</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all valid points of pointCloud that are inside or on the surface of given ball</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f02307f8c1e25c4c6af4fa18f8f2335" name="ga4f02307f8c1e25c4c6af4fa18f8f2335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f02307f8c1e25c4c6af4fa18f8f2335">&#9670;&#160;</a></span>findPointsInBall() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pointCloud</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ball3f &amp;</td>          <td class="paramname"><span class="paramname"><em>ball</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a421af22aea174a88968edea770000bbc">OnPointInBallFound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all valid points of pointCloud that are inside or on the surface of given ball until callback returns Stop; the ball can shrink (new ball is always within the previous one) during the search but never expand</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga835e26690b8579246b5fe66eecd773ac" name="ga835e26690b8579246b5fe66eecd773ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga835e26690b8579246b5fe66eecd773ac">&#9670;&#160;</a></span>findPointsInBox() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box3f &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all points in tree that are inside or on the surface of given box</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ebc24e7d3fa59c325ec9fed80e3f7c1" name="ga1ebc24e7d3fa59c325ec9fed80e3f7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ebc24e7d3fa59c325ec9fed80e3f7c1">&#9670;&#160;</a></span>findPointsInBox() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box3f &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all valid vertices of the mesh that are inside or on the surface of given box</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5fa4e215cb2613c2e801735695f22dd9" name="ga5fa4e215cb2613c2e801735695f22dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fa4e215cb2613c2e801735695f22dd9">&#9670;&#160;</a></span>findPointsInBox() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findPointsInBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pointCloud</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box3f &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a30cd2d38272cf5fb35c10a421b4d2045">FoundPointCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all valid points of pointCloud that are inside or on the surface of given box</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xf</td><td>points-to-center transformation, if not specified then identity transformation is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa20d785f3f82fad58fb659bc0009563d" name="gaa20d785f3f82fad58fb659bc0009563d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa20d785f3f82fad58fb659bc0009563d">&#9670;&#160;</a></span>findProjection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> MR::findProjection </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>validFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>validProjections</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the closest point on mesh (or its region) to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exits returning upDistLimitSq and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>mesh-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
    <tr><td class="paramname">validFaces</td><td>if provided then only faces from there will be considered as projections </td></tr>
    <tr><td class="paramname">validProjections</td><td>if provided then only projections passed this test can be returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaccdf7712b3c2bc175e4b09aae138aa40" name="gaccdf7712b3c2bc175e4b09aae138aa40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccdf7712b3c2bc175e4b09aae138aa40">&#9670;&#160;</a></span>findProjectionOnMeshEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionResult3 MR::findProjectionOnMeshEdges </td>
          <td>(</td>
          <td class="paramtype">const Line3f &amp;</td>          <td class="paramname"><span class="paramname"><em>ln</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AABBTreePolyline3 &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on the mesh edges (specified by the tree) to given straight line </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger then the function exists returning upDistLimitSq and no valid point or edge </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64c37b9a7a04aa567390955a50891b57" name="ga64c37b9a7a04aa567390955a50891b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64c37b9a7a04aa567390955a50891b57">&#9670;&#160;</a></span>findProjectionOnMeshEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionResult3 MR::findProjectionOnMeshEdges </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AABBTreePolyline3 &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on the mesh edges (specified by the tree) to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger then the function exists returning upDistLimitSq and no valid point or edge </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc2ddddc1d6fae40b8efc80cc28d123a" name="gabc2ddddc1d6fae40b8efc80cc28d123a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc2ddddc1d6fae40b8efc80cc28d123a">&#9670;&#160;</a></span>findProjectionOnPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PointsProjectionResult.html">PointsProjectionResult</a> MR::findProjectionOnPoints </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMR_1_1AABBTreePoints.html">AABBTreePoints</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertPredicate</td>          <td class="paramname"><span class="paramname"><em>skipCb</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the closest point on <a class="el" href="classMR_1_1AABBTreePoints.html" title="bounding volume hierarchy for point cloud structure">AABBTreePoints</a> to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exits returning upDistLimitSq and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>pointcloud-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
    <tr><td class="paramname">skipCb</td><td>callback to discard VertId projection candidate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a9ede35586c7db2c8ab59c42bcd6b7d" name="ga8a9ede35586c7db2c8ab59c42bcd6b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a9ede35586c7db2c8ab59c42bcd6b7d">&#9670;&#160;</a></span>findProjectionOnPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1PointsProjectionResult.html">PointsProjectionResult</a> MR::findProjectionOnPoints </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertPredicate</td>          <td class="paramname"><span class="paramname"><em>skipCb</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the closest point on point cloud to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exits returning upDistLimitSq and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>pointcloud-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
    <tr><td class="paramname">skipCb</td><td>callback to discard VertId projection candidate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa484a0628a7ac3858cd590589687141c" name="gaa484a0628a7ac3858cd590589687141c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa484a0628a7ac3858cd590589687141c">&#9670;&#160;</a></span>findProjectionOnPolyline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionResult3 MR::findProjectionOnPolyline </td>
          <td>(</td>
          <td class="paramtype">const Line3f &amp;</td>          <td class="paramname"><span class="paramname"><em>ln</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline3 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on polyline to given straight line </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger then the function exists returning upDistLimitSq and no valid point or edge </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e71a300face382a26ba8596d9b19820" name="ga5e71a300face382a26ba8596d9b19820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e71a300face382a26ba8596d9b19820">&#9670;&#160;</a></span>findProjectionOnPolyline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionResult3 MR::findProjectionOnPolyline </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline3 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on polyline to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger then the function exists returning upDistLimitSq and no valid point or edge </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f7211a85409018fd8ee71495646faa3" name="ga7f7211a85409018fd8ee71495646faa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f7211a85409018fd8ee71495646faa3">&#9670;&#160;</a></span>findProjectionOnPolyline2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionResult2 MR::findProjectionOnPolyline2 </td>
          <td>(</td>
          <td class="paramtype">const Vector2f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on polyline to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger then the function exists returning upDistLimitSq and no valid point or edge </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2ef419d4414bb6d0efa0c918b21bddf" name="gaf2ef419d4414bb6d0efa0c918b21bddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ef419d4414bb6d0efa0c918b21bddf">&#9670;&#160;</a></span>findProjectionOnPolyline2WithOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#acdd7942df456145c6efbf9d6524f3f88">Polyline2ProjectionWithOffsetResult</a> MR::findProjectionOnPolyline2WithOffset </td>
          <td>(</td>
          <td class="paramtype">const Vector2f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt; float, UndirectedEdgeId &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>offsetPerEdge</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on polyline to given point, respecting each edge offset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsetPerEdge</td><td>offset for each edge of polyline </td></tr>
    <tr><td class="paramname">upDistLimit</td><td>upper limit on the distance in question, if the real distance is larger then the function exists returning upDistLimit and no valid point or edge </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimit</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga834d7e50b54b1b8c511990fc9d14c09c" name="ga834d7e50b54b1b8c511990fc9d14c09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga834d7e50b54b1b8c511990fc9d14c09c">&#9670;&#160;</a></span>findProjectionOnPolylineWithOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> PolylineProjectionWithOffsetResult3 MR::findProjectionOnPolylineWithOffset </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline3 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMR_1_1Vector.html">Vector</a>&lt; float, UndirectedEdgeId &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>offsetPerEdge</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the closest point on polyline to given point, respecting each edge offset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsetPerEdge</td><td>offset for each edge of polyline </td></tr>
    <tr><td class="paramname">upDistLimit</td><td>upper limit on the distance in question, if the real distance is larger then the function exists returning upDistLimit and no valid point or edge </td></tr>
    <tr><td class="paramname">xf</td><td>polyline-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimit</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga415d472754b9db893c0765c00951faad" name="ga415d472754b9db893c0765c00951faad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga415d472754b9db893c0765c00951faad">&#9670;&#160;</a></span>findProjectionSubtree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> MR::findProjectionSubtree </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMR_1_1AABBTree.html">AABBTree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>xf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>validFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structMR_1_1MeshProjectionResult.html">MeshProjectionResult</a> &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>validProjections</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the closest point on mesh (or its region) to given point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>explicitly given BVH-tree for whole mesh or part of mesh we are searching projection on, </td></tr>
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger than the function exits returning upDistLimitSq and no valid point </td></tr>
    <tr><td class="paramname">xf</td><td>mesh-to-point transformation, if not specified then identity transformation is assumed </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if a point is found within this distance then it is immediately returned without searching for a closer one </td></tr>
    <tr><td class="paramname">validFaces</td><td>if provided then only faces from there will be considered as projections </td></tr>
    <tr><td class="paramname">validProjections</td><td>if provided then only projections passed this test can be returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4fca223a68dac564f66af0224c0ec3ec" name="ga4fca223a68dac564f66af0224c0ec3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fca223a68dac564f66af0224c0ec3ec">&#9670;&#160;</a></span>findSelfCollidingEdgePairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgePointPair.html">EdgePointPair</a> &gt; MR::findSelfCollidingEdgePairs </td>
          <td>(</td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding edges from 2d polyline </p>

</div>
</div>
<a id="gad89aed99c2cba4cd08e06d896b839841" name="gad89aed99c2cba4cd08e06d896b839841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad89aed99c2cba4cd08e06d896b839841">&#9670;&#160;</a></span>findSelfCollidingEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1UndirectedEdgeUndirectedEdge.html">UndirectedEdgeUndirectedEdge</a> &gt; MR::findSelfCollidingEdges </td>
          <td>(</td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding edges from 2d polyline </p>

</div>
</div>
<a id="ga8658f18b6b0489c1dafa4903c64c0165" name="ga8658f18b6b0489c1dafa4903c64c0165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8658f18b6b0489c1dafa4903c64c0165">&#9670;&#160;</a></span>findSelfCollidingEdgesBS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> UndirectedEdgeBitSet MR::findSelfCollidingEdgesBS </td>
          <td>(</td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the union of all self-intersecting edges </p>

</div>
</div>
<a id="ga50f22b9cff7188bb21cc3c7d72ec4a03" name="ga50f22b9cff7188bb21cc3c7d72ec4a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50f22b9cff7188bb21cc3c7d72ec4a03">&#9670;&#160;</a></span>findSelfCollidingEdgeTrisPrecise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::vector&lt; <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &gt; MR::findSelfCollidingEdgeTrisPrecise </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../namespaceMR.html#ab81d3ad87ff9cd57deee77336ddf83e1">ConvertToIntVector</a></td>          <td class="paramname"><span class="paramname"><em>conv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>anyIntersection</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>aVertSizes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all pairs of colliding edges and triangle within one mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anyIntersection</td><td>if true then the function returns as fast as it finds any intersection </td></tr>
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation, might be useful to obtain same result as in boolean operation would for mesh B </td></tr>
    <tr><td class="paramname">aVertsSize</td><td>used in float to int conversion, might be useful to obtain same result as in boolean operation would for mesh B </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ac96d312ea833414d4d74069169cb1b" name="ga0ac96d312ea833414d4d74069169cb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ac96d312ea833414d4d74069169cb1b">&#9670;&#160;</a></span>findSelfCollidingTriangles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; std::vector&lt; <a class="el" href="structMR_1_1FaceFace.html">FaceFace</a> &gt; &gt; MR::findSelfCollidingTriangles </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a></td>          <td class="paramname"><span class="paramname"><em>cb</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Face2RegionMap *</td>          <td class="paramname"><span class="paramname"><em>regionMap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>touchIsIntersection</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds all pairs of colliding triangles from one mesh or a region </p>
<p>if true then treat touching faces as self-intersections too </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionMap</td><td>if regionMap is provided then only self-intersections within a region are returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga69b56b2d80a7923ebfeed5757d334e4f" name="ga69b56b2d80a7923ebfeed5757d334e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69b56b2d80a7923ebfeed5757d334e4f">&#9670;&#160;</a></span>findSelfCollidingTriangles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; bool &gt; MR::findSelfCollidingTriangles </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structMR_1_1FaceFace.html">FaceFace</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>outCollidingPairs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a></td>          <td class="paramname"><span class="paramname"><em>cb</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Face2RegionMap *</td>          <td class="paramname"><span class="paramname"><em>regionMap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>touchIsIntersection</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds all pairs (or the fact of any self-collision) of colliding triangles from one mesh or a region </p>
<p>if true then treat touching faces as self-intersections too </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outCollidingPairs</td><td>if nullptr then the algorithm returns with true as soon as first collision is found  </td></tr>
    <tr><td class="paramname">regionMap</td><td>if regionMap is provided then only self-intersections within a region are returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac946d92c431583fc7c4d656445ba1c07" name="gac946d92c431583fc7c4d656445ba1c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac946d92c431583fc7c4d656445ba1c07">&#9670;&#160;</a></span>findSelfCollidingTrianglesBS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#a6d7483b6adbc485e9c9b52eb09cb7735">Expected</a>&lt; FaceBitSet &gt; MR::findSelfCollidingTrianglesBS </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a></td>          <td class="paramname"><span class="paramname"><em>cb</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Face2RegionMap *</td>          <td class="paramname"><span class="paramname"><em>regionMap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>touchIsIntersection</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the same <a class="el" href="#ga69b56b2d80a7923ebfeed5757d334e4f">findSelfCollidingTriangles</a> but returns the union of all self-intersecting faces </p>
<p>if true then treat touching faces as self-intersections too </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionMap</td><td>if regionMap is provided then only self-intersections within a region are returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga23c1ed1442e2de62ef49a64b7179d809" name="ga23c1ed1442e2de62ef49a64b7179d809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23c1ed1442e2de62ef49a64b7179d809">&#9670;&#160;</a></span>findSignedDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshMeshSignedDistanceResult.html">MeshMeshSignedDistanceResult</a> MR::findSignedDistance </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes minimal distance between two meshes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the positive distance in question, if the real distance is larger than the function exists returning upDistLimitSq and no valid points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44d0cb5151cae38d27130277c50301bc" name="ga44d0cb5151cae38d27130277c50301bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d0cb5151cae38d27130277c50301bc">&#9670;&#160;</a></span>findSignedDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; <a class="el" href="structMR_1_1SignedDistanceToMeshResult.html">SignedDistanceToMeshResult</a> &gt; MR::findSignedDistance </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>upDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>loDistLimitSq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the closest point on mesh (or its region) to given point, and finds the distance with sign to it (positive - outside, negative - inside the mesh) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upDistLimitSq</td><td>upper limit on the distance in question, if the real distance is larger then the function exits returning nullopt </td></tr>
    <tr><td class="paramname">loDistLimitSq</td><td>low limit on the distance in question, if the real distance smaller then the function exits returning nullopt </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga354aa28c5105859923d024949d724b5f" name="ga354aa28c5105859923d024949d724b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga354aa28c5105859923d024949d724b5f">&#9670;&#160;</a></span>findTrisInBall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::findTrisInBall </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ball3f &amp;</td>          <td class="paramname"><span class="paramname"><em>ball</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ga3fa10deed3f5f765a28d62f2a9667c0f">FoundTriCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>validFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enumerates all triangles within the ball until callback returns Stop; the ball during enumeration can shrink (new ball is always within the previous one) but never expand </p>

</div>
</div>
<a id="ga994aaba24d39e18802b546f4fdab10cc" name="ga994aaba24d39e18802b546f4fdab10cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga994aaba24d39e18802b546f4fdab10cc">&#9670;&#160;</a></span>findTwoClosestPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="elRef" href="../namespaceMR.html#ad75ce80ca78d38bd524b9c4ccd7a520d">VertPair</a> MR::findTwoClosestPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1PointCloud.html">PointCloud</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__BasicStructuresGroup.html#ga51ff94746a41880cd06d3272b5bcf710">ProgressCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>progress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds two closest points (first id &lt; second id) in whole point cloud </p>

</div>
</div>
<a id="ga3c1bb6417aaa769fa4156f2edac91749" name="ga3c1bb6417aaa769fa4156f2edac91749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c1bb6417aaa769fa4156f2edac91749">&#9670;&#160;</a></span>getNumNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MR::getNumNodes </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numLeaves</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of nodes in the binary tree with given number of leaves </p>

</div>
</div>
<a id="ga125d7b99c7b4840e87a3470ef0c64b17" name="ga125d7b99c7b4840e87a3470ef0c64b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga125d7b99c7b4840e87a3470ef0c64b17">&#9670;&#160;</a></span>getVectorConverters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1CoordinateConverters.html">CoordinateConverters</a> MR::getVectorConverters </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates simple converters from Vector3f to Vector3i and back in mesh parts area range </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9984ed4cff38cd012243e835f02e0e92" name="ga9984ed4cff38cd012243e835f02e0e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9984ed4cff38cd012243e835f02e0e92">&#9670;&#160;</a></span>IntersectionPrecomputes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::IntersectionPrecomputes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gac2a5a2178c875139ca3e402c1a46324c" name="gac2a5a2178c875139ca3e402c1a46324c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a5a2178c875139ca3e402c1a46324c">&#9670;&#160;</a></span>IntersectionPrecomputes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::IntersectionPrecomputes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3c4d304b28fd4695d20dc454318f5660" name="ga3c4d304b28fd4695d20dc454318f5660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4d304b28fd4695d20dc454318f5660">&#9670;&#160;</a></span>isInside() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::isInside </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks that arbitrary mesh part A is inside of closed mesh part B </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8d770560279dcdaa48764810b77c30d" name="gaa8d770560279dcdaa48764810b77c30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d770560279dcdaa48764810b77c30d">&#9670;&#160;</a></span>isInside() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::isInside </td>
          <td>(</td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a800c9816563b894edca43508f9f6b56e">AffineXf2f</a> *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks that arbitrary 2d polyline A is inside of closed 2d polyline B </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-polyline space to A polyline space, nullptr considered as identity transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3358455877a4f3ab26bb581338d86cd4" name="ga3358455877a4f3ab26bb581338d86cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3358455877a4f3ab26bb581338d86cd4">&#9670;&#160;</a></span>isNonIntersectingInside() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::isNonIntersectingInside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceId</td>          <td class="paramname"><span class="paramname"><em>partFace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks that arbitrary mesh A part (whole part is represented by one face <code>partFace</code>) is inside of closed mesh part B The version of <code>isInside</code> without collision check; it is user's responsibility to guarantee that the meshes don't collide </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30d53ebf69ce150861f17e4695543778" name="ga30d53ebf69ce150861f17e4695543778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30d53ebf69ce150861f17e4695543778">&#9670;&#160;</a></span>isNonIntersectingInside() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::isNonIntersectingInside </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineXf3f *</td>          <td class="paramname"><span class="paramname"><em>rigidB2A</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks that arbitrary mesh part A is inside of closed mesh part B The version of <code>isInside</code> without collision check; it is user's responsibility to guarantee that the meshes don't collide </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rigidB2A</td><td>rigid transformation from B-mesh space to A mesh space, nullptr considered as identity transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2aba3040bbdbbafb7d8e38803b955524" name="ga2aba3040bbdbbafb7d8e38803b955524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aba3040bbdbbafb7d8e38803b955524">&#9670;&#160;</a></span>isPointInsidePolyline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> bool MR::isPointInsidePolyline </td>
          <td>(</td>
          <td class="paramtype">const Polyline2 &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2f &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>detect if given point is inside polyline, by counting ray intersections </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polyline</td><td>input polyline </td></tr>
    <tr><td class="paramname">point</td><td>input point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga364302ddaf673e7f00c6745f4172d6c0" name="ga364302ddaf673e7f00c6745f4172d6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga364302ddaf673e7f00c6745f4172d6c0">&#9670;&#160;</a></span>makeAABBTreeNodeVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga01c75e3c26967a90edbe075a77cb2ca9">AABBTreeNodeVec</a>&lt; T &gt; MR::makeAABBTreeNodeVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMR_1_1Buffer.html">Buffer</a>&lt; <a class="el" href="structMR_1_1BoxedLeaf.html">BoxedLeaf</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>boxedLeaves</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga041f851064ebbb5159343f98539fc045" name="ga041f851064ebbb5159343f98539fc045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga041f851064ebbb5159343f98539fc045">&#9670;&#160;</a></span>multiRayMeshIntersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::multiRayMeshIntersect </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>meshPart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector3f &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>origins</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector3f &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dirs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1MultiRayMeshIntersectResult.html">MultiRayMeshIntersectResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rayStart</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rayEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>closestIntersect</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>validFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds intersections between a mesh and multiple rays in parallel (in float-precision). <code>rayStart</code> and <code>rayEnd</code> define the interval on all rays to detect an intersection. <code>vadidFaces</code> if given then all faces for which false is returned will be skipped </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshPart</td><td>mesh (or its part) to find intersections with  </td></tr>
    <tr><td class="paramname">origins</td><td>origin point of every ray  </td></tr>
    <tr><td class="paramname">dirs</td><td>direction of every ray  </td></tr>
    <tr><td class="paramname">result</td><td>output data for every ray  </td></tr>
    <tr><td class="paramname">closestIntersect</td><td>finds the closest to ray origin intersection (or any intersection for better performance if <code>!closestIntersect</code>)  </td></tr>
    <tr><td class="paramname">validFaces</td><td>if given then all faces for which false is returned will be skipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f7cfd40975f9648e9785f72d75ff92d" name="ga8f7cfd40975f9648e9785f72d75ff92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f7cfd40975f9648e9785f72d75ff92d">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MR::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1EdgeTri.html">EdgeTri</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8b2db465de4ef2df4f0f85fa142a612f" name="ga8b2db465de4ef2df4f0f85fa142a612f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b2db465de4ef2df4f0f85fa142a612f">&#9670;&#160;</a></span>planeMeshIntersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::planeMeshIntersect </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>meshPart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Plane3f &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>fs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UndirectedEdgeBitSet *</td>          <td class="paramname"><span class="paramname"><em>ues</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertBitSet *</td>          <td class="paramname"><span class="paramname"><em>vs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; FaceId &gt; *</td>          <td class="paramname"><span class="paramname"><em>fsVec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>given mesh part and arbitrary plane, outputs </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>triangles from boxes crossed or touched by the plane </td></tr>
    <tr><td class="paramname">ues</td><td>edges of these triangles </td></tr>
    <tr><td class="paramname">vs</td><td>vertices of these triangles </td></tr>
    <tr><td class="paramname">fsVec</td><td>triangles from boxes crossed or touched by the plane in unspecified order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb20234daa82631954c44c1676424e5f" name="gadb20234daa82631954c44c1676424e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb20234daa82631954c44c1676424e5f">&#9670;&#160;</a></span>processCloseTriangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::processCloseTriangles </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#ac3b4f93ff16dbb5975ce8dec6adc39cf">Triangle3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rangeSq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ga285ea5cd9fb638c90fec0099f526c057">TriangleCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>call</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>invokes given callback for all triangles from given mesh part located not further than given squared distance from t-triangle </p>

</div>
</div>
<a id="ga987d32cc52268b780f26e3733f7d0151" name="ga987d32cc52268b780f26e3733f7d0151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987d32cc52268b780f26e3733f7d0151">&#9670;&#160;</a></span>rayMeshIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a> MR::rayMeshIntersect </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>meshPart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Line3d &amp;</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rayStart</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rayEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DBL_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>closestIntersect</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>validFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds ray and mesh intersection in double-precision. <code>rayStart</code> and <code>rayEnd</code> define the interval on the ray to detect an intersection. <code>prec</code> can be specified to reuse some precomputations (e.g. for checking many parallel rays). <code>vadidFaces</code> if given then all faces for which false is returned will be skipped Finds the closest to ray origin intersection (or any intersection for better performance if <code>!closestIntersect</code>). </p>

</div>
</div>
<a id="ga4a4bcd2a0d206e01852cba4f6e0c2a6b" name="ga4a4bcd2a0d206e01852cba4f6e0c2a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a4bcd2a0d206e01852cba4f6e0c2a6b">&#9670;&#160;</a></span>rayMeshIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MeshIntersectionResult.html">MeshIntersectionResult</a> MR::rayMeshIntersect </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>meshPart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Line3f &amp;</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rayStart</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rayEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; float &gt; *</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>closestIntersect</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../namespaceMR.html#a2b15c0d875f91b8c0da03e651251832b">FacePredicate</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>validFaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds ray and mesh intersection in float-precision. <code>rayStart</code> and <code>rayEnd</code> define the interval on the ray to detect an intersection. <code>prec</code> can be specified to reuse some precomputations (e.g. for checking many parallel rays). <code>vadidFaces</code> if given then all faces for which false is returned will be skipped Finds the closest to ray origin intersection (or any intersection for better performance if <code>!closestIntersect</code>). </p>

</div>
</div>
<a id="ga4f7fec7775a22ca743ad08d9b8ae3056" name="ga4f7fec7775a22ca743ad08d9b8ae3056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f7fec7775a22ca743ad08d9b8ae3056">&#9670;&#160;</a></span>rayMeshIntersectAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::rayMeshIntersectAll </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>meshPart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Line3d &amp;</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gac20cf6ba073a7db1e2df313fb87d9517">MeshIntersectionCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rayStart</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rayEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DBL_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#rayMeshIntersectAllF">rayMeshIntersectAllF</a>, but use double precision. </p>

</div>
</div>
<a id="gac978c520f500c1e3dad2ddaff7a333f0" name="gac978c520f500c1e3dad2ddaff7a333f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac978c520f500c1e3dad2ddaff7a333f0">&#9670;&#160;</a></span>rayMeshIntersectAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::rayMeshIntersectAll </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>meshPart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Line3f &amp;</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gac20cf6ba073a7db1e2df313fb87d9517">MeshIntersectionCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rayStart</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rayEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1IntersectionPrecomputes.html">IntersectionPrecomputes</a>&lt; float &gt; *</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersects ray with mesh. Finds all intersections <a class="anchor" id="rayMeshIntersectAllF"></a> </p>

</div>
</div>
<a id="gaca3917c935c4b071cac785463beaa5f2" name="gaca3917c935c4b071cac785463beaa5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca3917c935c4b071cac785463beaa5f2">&#9670;&#160;</a></span>rayMultiMeshAnyIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MultiMeshIntersectionResult.html">MultiMeshIntersectionResult</a> MR::rayMultiMeshAnyIntersect </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#ga8ba650839d7806773bb542b986ac4283">Line3dMesh</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lineMeshes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rayStart</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rayEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DBL_MAX</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#rayMultiMeshAnyIntersectF">rayMultiMeshAnyIntersectF</a>, but use double precision. </p>

</div>
</div>
<a id="ga5ed53546770d894ff3f4ea75bd760afa" name="ga5ed53546770d894ff3f4ea75bd760afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ed53546770d894ff3f4ea75bd760afa">&#9670;&#160;</a></span>rayMultiMeshAnyIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> <a class="el" href="structMR_1_1MultiMeshIntersectionResult.html">MultiMeshIntersectionResult</a> MR::rayMultiMeshAnyIntersect </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#ga9222ec2d954badb7ee5874321a084eb6">Line3fMesh</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lineMeshes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rayStart</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rayEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FLT_MAX</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Intersects ray with many meshes. Finds any intersection (not the closest) <a class="anchor" id="rayMultiMeshAnyIntersectF"></a> </p>

</div>
</div>
<a id="gab849769857dbeadbea5f6bbfa749dfa0" name="gab849769857dbeadbea5f6bbfa749dfa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab849769857dbeadbea5f6bbfa749dfa0">&#9670;&#160;</a></span>signedDistanceToMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> std::optional&lt; float &gt; MR::signedDistanceToMesh </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>mp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3f &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMR_1_1SignedDistanceToMeshOptions.html">SignedDistanceToMeshOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes signed distance from point (p) to mesh part (mp) following options (op); returns std::nullopt if distance is smaller than op.minDist or larger than op.maxDist (except for op.signMode == HoleWindingRule) </p>

</div>
</div>
<a id="ga4b8be9888719bfd9c5944dc6293c902d" name="ga4b8be9888719bfd9c5944dc6293c902d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b8be9888719bfd9c5944dc6293c902d">&#9670;&#160;</a></span>xyPlaneMeshIntersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MRMesh_2MRMeshFwd_8h.html#a08ff09fd7e75c029b08cc255b0734300">MRMESH_API</a> void MR::xyPlaneMeshIntersect </td>
          <td>(</td>
          <td class="paramtype">const MeshPart &amp;</td>          <td class="paramname"><span class="paramname"><em>meshPart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>zLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceBitSet *</td>          <td class="paramname"><span class="paramname"><em>fs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UndirectedEdgeBitSet *</td>          <td class="paramname"><span class="paramname"><em>ues</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertBitSet *</td>          <td class="paramname"><span class="paramname"><em>vs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; FaceId &gt; *</td>          <td class="paramname"><span class="paramname"><em>fsVec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>given mesh part and plane z=zLevel, outputs </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>triangles crossed or touched by the plane </td></tr>
    <tr><td class="paramname">ues</td><td>edges of these triangles </td></tr>
    <tr><td class="paramname">vs</td><td>vertices of these triangles </td></tr>
    <tr><td class="paramname">fsVec</td><td>triangles crossed or touched by the plane in unspecified order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga59240ce19dcf5b27221a347b22086fcb" name="ga59240ce19dcf5b27221a347b22086fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59240ce19dcf5b27221a347b22086fcb">&#9670;&#160;</a></span>idxX</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::idxX = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1e89bb11cf7c4693e1c8839963994a08" name="ga1e89bb11cf7c4693e1c8839963994a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e89bb11cf7c4693e1c8839963994a08">&#9670;&#160;</a></span>idxY</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::idxY = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5e3f58e5a000086f4df8523da65c9b4f" name="ga5e3f58e5a000086f4df8523da65c9b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e3f58e5a000086f4df8523da65c9b4f">&#9670;&#160;</a></span>invDir</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMR_1_1Vector3.html">Vector3</a>&lt;T&gt; <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::invDir</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaffa5bcb7a516c4dda421ace86e2597c2" name="gaffa5bcb7a516c4dda421ace86e2597c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffa5bcb7a516c4dda421ace86e2597c2">&#9670;&#160;</a></span>maxDimIdxZ</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::maxDimIdxZ = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga28372a635ba67b43220bc9067be6560d" name="ga28372a635ba67b43220bc9067be6560d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28372a635ba67b43220bc9067be6560d">&#9670;&#160;</a></span>sign</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector3i <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::sign</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stores signs of direction vector; </p>

</div>
</div>
<a id="ga21465bc7d67177777744f39ac171940c" name="ga21465bc7d67177777744f39ac171940c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21465bc7d67177777744f39ac171940c">&#9670;&#160;</a></span>Sx</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::Sx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>precomputed factors </p>

</div>
</div>
<a id="gaf95502c89221bba3187782d4ed18199b" name="gaf95502c89221bba3187782d4ed18199b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf95502c89221bba3187782d4ed18199b">&#9670;&#160;</a></span>Sy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::Sy</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6159c869b0afc38ccf26091c1681194a" name="ga6159c869b0afc38ccf26091c1681194a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6159c869b0afc38ccf26091c1681194a">&#9670;&#160;</a></span>Sz</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structMR_1_1IntersectionPrecomputes.html">MR::IntersectionPrecomputes</a>&lt; T &gt;::Sz</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.11.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a rel="nofollow" href="https://www.doxygen.nl/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
